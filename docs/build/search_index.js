var documenterSearchIndex = {"docs":
[{"location":"01_install/#installation","page":"Installation & requirements","title":"Installation & requirements","text":"","category":"section"},{"location":"01_install/#Manual-installation","page":"Installation & requirements","title":"Manual installation","text":"","category":"section"},{"location":"01_install/","page":"Installation & requirements","title":"Installation & requirements","text":"Download the folder from Github.  First, it is necessary to install the Julia from https://julialang.org/.    Next, the user need to copy the project folder in the chosen working directory. ","category":"page"},{"location":"01_install/","page":"Installation & requirements","title":"Installation & requirements","text":"Using REPL or the COMMAND LINE move to the working directory.  \nIf you use the COMMAND LINE, to start a Julia session run the command:","category":"page"},{"location":"01_install/","page":"Installation & requirements","title":"Installation & requirements","text":"julia","category":"page"},{"location":"01_install/","page":"Installation & requirements","title":"Installation & requirements","text":"To enter in the Pkg REPL  type ","category":"page"},{"location":"01_install/","page":"Installation & requirements","title":"Installation & requirements","text":"]  ","category":"page"},{"location":"01_install/","page":"Installation & requirements","title":"Installation & requirements","text":"Type the command ","category":"page"},{"location":"01_install/","page":"Installation & requirements","title":"Installation & requirements","text":"activate .","category":"page"},{"location":"01_install/","page":"Installation & requirements","title":"Installation & requirements","text":"To activate the JMAKi project, type","category":"page"},{"location":"01_install/","page":"Installation & requirements","title":"Installation & requirements","text":"instantiate","category":"page"},{"location":"01_install/","page":"Installation & requirements","title":"Installation & requirements","text":"at the start of the code or notebook (where you are going to do analyses) you should write ","category":"page"},{"location":"01_install/","page":"Installation & requirements","title":"Installation & requirements","text":"using DifferentialEquations\nusing Optimization\nusing Plots\nusing Random\nusing CSV\nusing DataFrames\nusing Statistics\nusing Optim\nusing OptimizationBBO\nusing NaNMath\nusing StatsBase\nusing Tables\nusing Distributions\nusing Interpolations\nusing Peaks\nusing ChangePointDetection\nusing Lowess  \nusing  LsqFit\nusing Combinatorics\nusing MLJ\nusing SymbolicRegression\nusing Zygote\nusing DelimitedFiles\nusing BetaML\nusing DecisionTree\nusing MLJDecisionTreeInterface\ninclude(\"your_path_to_JMAKi_main_folder/src/functions.jl\")\n\n","category":"page"},{"location":"01_install/","page":"Installation & requirements","title":"Installation & requirements","text":"this last step is Temporary before the official realese","category":"page"},{"location":"01_install/#Package-installation","page":"Installation & requirements","title":"Package installation","text":"","category":"section"},{"location":"01_install/#Requirements","page":"Installation & requirements","title":"Requirements","text":"","category":"section"},{"location":"01_install/#Dependencies","page":"Installation & requirements","title":"Dependencies","text":"","category":"section"},{"location":"01_install/","page":"Installation & requirements","title":"Installation & requirements","text":"Julia (1.7,1.8,1.9)\nDifferentialEquations\nOptimization\nPlots\nRandom\nCSV\nDataFrames\nStatistics\nOptim\nOptimizationBBO\nNaNMath\nStatsBase\nTables\nDistributions\nInterpolations\nPeaks\nChangePointDetection\nLowess\nLsqFit\nCombinatorics","category":"page"},{"location":"api/#API","page":"API","title":"API","text":"","category":"section"},{"location":"api/#Pre-processing-functions","page":"API","title":"Pre-processing functions","text":"","category":"section"},{"location":"api/#Smoothing-data","page":"API","title":"Smoothing data","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"JMAKi.smoothing_data","category":"page"},{"location":"api/","page":"API","title":"API","text":"JMAKi.smoothing_data","category":"page"},{"location":"api/#JMAKi.smoothing_data","page":"API","title":"JMAKi.smoothing_data","text":"smoothing_data(\ndata::Matrix{Float64};\nmethod=\"rolling_avg\",\npt_avg=7,\nthr_lowess=0.05\n)\n\nArguments:\n\ndata: Matrix of data 2xn_time points, it is a single curve.\nmethod=\"rolling_avg\": String, How to smooth the data, options: \"NO\" , \"rolling avg\" rolling average of the data, and \"lowess\".\npt_avg=7: Number of points to generate the initial condition or do the rolling avg smoothing.\nthr_lowess=0.05: Float64 keyword argument of lowees smoothing\n\nOutput:\n\ndata_fin, array of smoothed data\n\n\n\n\n\n","category":"function"},{"location":"api/#Correction-for-multiple-scattering","page":"API","title":"Correction for multiple scattering","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"JMAKi.correction_OD_multiple_scattering","category":"page"},{"location":"api/","page":"API","title":"API","text":"JMAKi.correction_OD_multiple_scattering","category":"page"},{"location":"api/#JMAKi.correction_OD_multiple_scattering","page":"API","title":"JMAKi.correction_OD_multiple_scattering","text":"correction_OD_multiple_scattering(\ndata::Matrix{Float64},\ncalibration_curve::String;\nmethod=\"interpolation\"\n)\n\nDoes the multiple scattering correction of one time series\n\nArguments:\n\ndata:  matrix of data 2xn_time points, it is a single curve.\ncalibration_OD_curve=\"NA\": String, The path where the .csv calibration data are located, used only if multiple_scattering_correction=true.\nmethod: String, How perform the inference of multiple scattering curve, options: '\"interpolation\"' or   '\"exp_fit\"' it uses an exponential fit from \"Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications\"\n\nOutput:\n\n'data_fin' corrected data\n\n\n\n\n\n","category":"function"},{"location":"api/#Fitting-one-kinetics","page":"API","title":"Fitting one kinetics","text":"","category":"section"},{"location":"api/#Log-Lin-fitting","page":"API","title":"Log-Lin fitting","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"JMAKi.fitting_one_well_Log_Lin","category":"page"},{"location":"api/","page":"API","title":"API","text":"JMAKi.fitting_one_well_Log_Lin","category":"page"},{"location":"api/#JMAKi.fitting_one_well_Log_Lin","page":"API","title":"JMAKi.fitting_one_well_Log_Lin","text":"fitting_one_well_Log_Lin(\ndata::Matrix{Float64},\nname_well::String,\nlabel_exp::String; \ndisplay_plots=false,\nsave_plot=false,\npath_to_plot=\"NA\", \ntype_of_smoothing=\"rolling_avg\"\npt_avg=7, \npt_smoothing_derivative=7, \npt_min_size_of_win=7, \ntype_of_win=\"maximum\",\nthreshold_of_exp=0.9, \nmultiple_scattering_correction=false, \nmethod_multiple_scattering_correction=\"interpolation\",\ncalibration_OD_curve=\"NA\", \nthr_lowess=0.05, \n)\n\nThis function fits a logarithmic-linear model to the data of a single well. It evaluates the specific growth rate and with a statistical threshold it indentify a exponential window to perform the log-lin fitting.\n\nArguments:\n\ndata::Matrix{Float64}: The dataset with the growth curve, where the first row represents times, and the second row represents the variable to fit (e.g., OD), see documentation.\nname_well::String: The name of the well.\nlabel_exp::String: The label of the experiment.\n\nKey Arguments:\n\npath_to_plot=\"NA\": String, path to save the plots.\nsave_plot=false: Bool, save the plot or not\ndisplay_plots=true: Bool,  Whether or not diplay the plot in julia\ntype_of_smoothing=\"rolling_avg\": String, How to smooth the data, options: \"NO\" , \"rolling avg\" rolling average of the data, and \"lowess\"\npt_avg=7: Int, The number of points to do rolling average smoothing.\npt_smoothing_derivative=7: Int,  Number of points for evaluation of specific growth rate. If <2 it uses interpolation algorithm otherwise a sliding window approach.\npt_min_size_of_win=7: Int, The minimum size of the exponential windows in the number of smoothed points.\ntype_of_win=\"maximum\": String, How the exponential phase window is selected (\"maximum\" or \"global_thr\").\nthreshold_of_exp=0.9: Float, The threshold of the growth rate in quantile to define the exponential windows, a value between 0 and 1.\nmultiple_scattering_correction=false: Bool, Whether or not correct the data qith a calibration curve.\ncalibration_OD_curve=\"NA\": String, The path where the .csv calibration data are located, used only if multiple_scattering_correction=true.\nmultiple_scattering_correction=false: Bool, if true uses the given calibration curve to correct the data for muliple scattering.\nmethod_multiple_scattering_correction=\"interpolation\": String, How perform the inference of multiple scattering curve, options: \"interpolation\" or \"exp_fit\" it uses an exponential fit from \"Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications\"\nthr_lowess=0.05: Float64 keyword argument of lowees smoothing.\n\nOutput:\n\nan array with the following contents:\n\nresults_lin_log_fit = [label_exp, name_well, start of exp win, end of exp win, start of exp win, Maximum specific GR, specific GR, 2 sigma  CI of GR, doubling time,doubling time - 2 sigma, doubling time + 2 sigma, intercept log-lin fitting, 2 sigma intercept, R^2]\n\nThe plots of the log-linear fitting and of the dynamics of specific growth rate if save_plot=true or display_plots=true.\n\n\n\n\n\n","category":"function"},{"location":"api/#ODE-fitting","page":"API","title":"ODE fitting","text":"","category":"section"},{"location":"api/#Fitting-a-harcoded-model","page":"API","title":"Fitting a harcoded model","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"JMAKi.fitting_one_well_ODE_constrained","category":"page"},{"location":"api/","page":"API","title":"API","text":"JMAKi.fitting_one_well_ODE_constrained","category":"page"},{"location":"api/#JMAKi.fitting_one_well_ODE_constrained","page":"API","title":"JMAKi.fitting_one_well_ODE_constrained","text":"fitting_one_well_ODE_constrained(\ndata::Matrix{Float64},\nname_well::String, \nlabel_exp::String, \nmodel::String, \nlb_param::Vector{Float64},\nub_param::Vector{Float64};\nparam=lb_param .+ (ub_param .- lb_param) ./ 2,\noptmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(), \nintegrator=Tsit5(), \ndisplay_plots=true, \nsave_plot=false,\npath_to_plot=\"NA\", \npt_avg=1, \npt_smooth_derivative=7,\nsmoothing=false,\ntype_of_smoothing=\"rolling_avg\",\ntype_of_loss=\"RE\",\nblank_array=zeros(100), \nmultiple_scattering_correction=false,\nmethod_multiple_scattering_correction=\"interpolation\",\ncalibration_OD_curve=\"NA\",  \nPopulationSize=300,\nmaxiters=2000000,\nabstol=0.00001,\nthr_lowess=0.05,\n)\n\nThis function performs fitting on a single well's data using an ordinary differential equation (ODE) model. It estimates the model parameters within specified lower and upper bounds.\n\nArguments:\n\ndata::Matrix{Float64}: The dataset with the growth curve, where the first row represents times, and the second row represents the variable to fit (e.g., OD), see documentation.\nmodel::String: ODE model to use\nname_well::String: Name of the well.\nlabel_exp::String: Label of the experiment.\nlb_param::Vector{Float64}: Lower bounds of the model parameters.\nub_param::Vector{Float64}: Upper bounds of the model parameters.\n\nKey Arguments:\n\nparam= lb_param .+ (ub_param.-lb_param)./2:Vector{Float64}, Initial guess for the model parameters.\n`integrator =Tsit5()' sciML integrator. If using piecewise model please use  'KenCarp4(autodiff=true)'.\noptmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited() optimizer from optimizationBBO.\nsave_plot=false :Bool, save the plot or not.\ndisplay_plots=true:Bool,  Whether or not diplay the plot in julia.\ntype_of_smoothing=\"rolling_avg\": String, How to smooth the data, options: \"NO\" , \"rolling avg\" rolling average of the data, and \"lowess\".\npt_avg=7: Number of points to generate the initial condition or do the rolling avg smoothing.\nsmoothing=false: Whether to apply smoothing to the data or not.\ntype_of_loss:=\"RE\": Type of loss function to be used. (options= \"RE\", \"L2\", \"L2derivative\" and \"blankweighted_L2\").\nblank_array=zeros(100): Data of all blanks in single array.\npt_smoothing_derivative=7:Int,  Number of points for evaluation of specific growth rate. If <2 it uses interpolation algorithm otherwise a sliding window approach.\ncalibration_OD_curve=\"NA\": String, The path where the .csv calibration data are located, used only if multiple_scattering_correction=true.\nmultiple_scattering_correction=false: Bool, if true uses the given calibration curve to correct the data for muliple scattering.\nmethod_multiple_scattering_correction=\"interpolation\": String, How perform the inference of multiple scattering curve, options: \"interpolation\" or   \"exp_fit\" it uses an exponential fit from \"Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications\"\nthr_lowess=0.05: Float64 keyword argument of lowees smoothing\nPopulationSize =100: Size of the population of the optimization\nmaxiters=2000000: stop criterion, the optimization is stopped when the number of iterations is bigger than maxiters\nabstol = 0.00001: stop criterion, the optimization is stopped when the loss is lesser than abstol\n\nOutput (if results_ODE_fit =fitting_one_well_ODE_constrained(...):\n\nresults_ODE_fit[1] an array with the following contents: [\"name of model\", \"well\", \"param_1\",\"param_2\",..,\"param_n\",\"maximum specific gr using ode\",\"maximum specific gr using data\", \"objective function value (i.e. loss of the solution)\"]\n\nwhere ' \"param1\",\"param2\",..,\"param_n\" ' are the parameter of the selected ODE as in the documentation.\n\nresults_ODE_fit[2] the times of the fitted ODE\nresults_ODE_fit[3] the numerical solution of the fitted ODE\nThe plot of the  fitting  if do_plot=true\n\n\n\n\n\n","category":"function"},{"location":"api/#Fitting-a-custom-model","page":"API","title":"Fitting a custom model","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"JMAKi.fitting_one_well_custom_ODE","category":"page"},{"location":"api/","page":"API","title":"API","text":"JMAKi.fitting_one_well_custom_ODE","category":"page"},{"location":"api/#JMAKi.fitting_one_well_custom_ODE","page":"API","title":"JMAKi.fitting_one_well_custom_ODE","text":"fitting_one_well_custom_ODE(\ndata::Matrix{Float64}\nname_well::String, \nlabel_exp::String, \nmodel::Any, \nlb_param::Vector{Float64},\nub_param::Vector{Float64},\nn_equation::Int;\nparam=lb_param .+ (ub_param .- lb_param) ./ 2,\noptmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(), \nintegrator=Tsit5(), \ndisplay_plots=false, \nsave_plot=false,\npath_to_plot=\"NA\", \npt_avg=1, \npt_smooth_derivative=0,\nsmoothing=false, \ntype_of_loss=\"RE\",\nblank_array=zeros(100), \nmultiple_scattering_correction=false, \nmethod_multiple_scattering_correction=\"interpolation\",\ncalibration_OD_curve=\"NA\",  \nPopulationSize=300,\nmaxiters=2000000,\nabstol=0.00001,\nthr_lowess=0.05,\ntype_of_smoothing=\"lowess\",\n)\n\nThis function is designed for fitting an ordinary differential equation (ODE) model to a dataset representing the growth curve of a microorganism in a well.\n\nArguments:\n\ndata::Matrix{Float64}: The dataset with the growth curve, where the first row represents times, and the second row represents the variable to fit (e.g., OD), see documentation.\nmodel::Any: Function of the ODE to be fitted. See the documentation for examples.\nname_well::String: Name of the well.\nlabel_exp::String: Label of the experiment.\nlb_param::Vector{Float64}: Lower bounds of the model parameters.\nub_param::Vector{Float64}: Upper bounds of the model parameters.\nn_equation::Int:  number ode in the system\n\nKey Arguments:\n\nparam= lb_param .+ (ub_param.-lb_param)./2:Vector{Float64}, Initial guess for the model parameters.\n`integrator =Tsit5()' sciML integrator. If using piecewise model please use  'KenCarp4(autodiff=true)'.\noptmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited() optimizer from optimizationBBO.\nsave_plot=false :Bool, save the plot or not.\ndisplay_plots=true:Bool,  Whether or not diplay the plot in julia.\ntype_of_smoothing=\"rolling_avg\": String, How to smooth the data, options: \"NO\" , \"rolling avg\" rolling average of the data, and \"lowess\".\npt_avg=7: Number of points to generate the initial condition or do the rolling avg smoothing.\npt_smoothing_derivative=7:Int,  Number of points for evaluation of specific growth rate. If <2 it uses interpolation algorithm otherwise a sliding window approach.\nsmoothing=false: Whether to apply smoothing to the data or not.\ntype_of_loss:=\"RE\": Type of loss function to be used. (options= \"RE\", \"L2\", \"L2derivative\" and \"blankweighted_L2\").\nblank_array=zeros(100): Data of all blanks in single array.\ncalibration_OD_curve=\"NA\": String, The path where the .csv calibration data are located, used only if multiple_scattering_correction=true.\nmultiple_scattering_correction=false: Bool, if true uses the given calibration curve to correct the data for muliple scattering.\nmethod_multiple_scattering_correction=\"interpolation\": String, How perform the inference of multiple scattering curve, options: \"interpolation\" or   \"exp_fit\" it uses an exponential fit from \"Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications\"\nthr_lowess=0.05: Float64 keyword argument of lowees smoothing\nPopulationSize =100: Size of the population of the optimization\nmaxiters=2000000: stop criterion, the optimization is stopped when the number of iterations is bigger than maxiters\nabstol = 0.00001: stop criterion, the optimization is stopped when the loss is lesser than abstol\n\nOutput (if results_ODE_fit =fitting_one_well_custom_ODE(...):\n\nresults_ODE_fit[1] an array with the following contents: [\"name of model\", \"well\", \"param_1\",\"param_2\",..,\"param_n\",\"maximum specific gr using ode\",\"maximum specific gr using data\", \"objective function value (i.e. loss of the solution)\"]\n\nwhere ' \"param1\",\"param2\",..,\"param_n\" ' are the parameter of the used ODE.\n\nThe plot of the  fitting  if do_plot=true\n\n\n\n\n\n","category":"function"},{"location":"api/#ODE-model-selection","page":"API","title":"ODE model selection","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"JMAKi.ODE_Model_selection","category":"page"},{"location":"api/","page":"API","title":"API","text":"JMAKi.ODE_Model_selection","category":"page"},{"location":"api/#JMAKi.ODE_Model_selection","page":"API","title":"JMAKi.ODE_Model_selection","text":"ODE_Model_selection(\ndata::Matrix{Float64},\nname_well::String,\nlabel_exp::String, \nmodels_list::Vector{String}, \nlb_param_array::Any, \nub_param_array::Any; \noptmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(), \nintegrator=Tsit5(), \npt_avg=1,\nbeta_penality=2.0,\nsmoothing=false,\ntype_of_smoothing=\"lowess\",\nthr_lowess=0.05,\ntype_of_loss=\"L2\",\nblank_array=zeros(100),\ndisplay_plot_best_model=false, \nsave_plot_best_model=false,\npath_to_plot=\"NA\",\npt_smooth_derivative=7,\nmultiple_scattering_correction=false, \nmethod_multiple_scattering_correction=\"interpolation\",\ncalibration_OD_curve=\"NA\", \nverbose=false,\nPopulationSize=300,\nmaxiters=2000000,\nabstol=0.00001,\ncorrection_AIC=true,)\n\nThis function performs model selection based on a dataset representing the growth curve of a microorganism in a well. It evaluates multiple ODE models and selects the best-fitting model using the Akaike Information Criterion (AIC) or corrected AIC (AICc).\n\nArguments:\n\ndata::Matrix{Float64}: The dataset with the growth curve, where the first row represents times, and the second row represents the variable to fit (e.g., OD), see documentation.\nmodels_list::Vector{String}: list of ODE model used\nname_well::String: Name of the well.\nlabel_exp::String: Label of the experiment.\nmodels_list::Vector{String}: A vector of ODE models to evaluate.\nlb_param_array::Any: Lower bounds for the parameters (compatible with the models).\nub_param_array::Any: Upper bounds for the parameters (compatible with the models).\n\nKey Arguments:\n\nparam= lb_param .+ (ub_param.-lb_param)./2:Vector{Float64}, Initial guess for the model parameters.\n`integrator =Tsit5()' sciML integrator. If using piecewise model please use  'KenCarp4(autodiff=true)'.\noptmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited() optimizer from optimizationBBO.\nsave_plot_best_model=false :Bool, save the plot or not.\ndisplay_plot_best_model=true:Bool,  Whether or not diplay the plot in julia.\ntype_of_smoothing=\"rolling_avg\": String, How to smooth the data, options: \"NO\" , \"rolling avg\" rolling average of the data, and \"lowess\".\npt_avg=7: Number of points to generate the initial condition or do the rolling avg smoothing.\npt_smoothing_derivative=7:Int,  Number of points for evaluation of specific growth rate. If <2 it uses interpolation algorithm otherwise a sliding window approach.\nsmoothing=false: Whether to apply smoothing to the data or not.\ntype_of_loss:=\"RE\": Type of loss function to be used. (options= \"RE\", \"L2\", \"L2derivative\" and \"blankweighted_L2\").\nblank_array=zeros(100): Data of all blanks in single array.\ncalibration_OD_curve=\"NA\": String, The path where the .csv calibration data are located, used only if multiple_scattering_correction=true.\nmultiple_scattering_correction=false: Bool, if true uses the given calibration curve to correct the data for muliple scattering.\nmethod_multiple_scattering_correction=\"interpolation\": String, How perform the inference of multiple scattering curve, options: \"interpolation\" or   \"exp_fit\" it uses an exponential fit from \"Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications\"\nthr_lowess=0.05: Float64 keyword argument of lowees smoothing\nPopulationSize =100: Size of the population of the optimization\nmaxiters=2000000: stop criterion, the optimization is stopped when the number of iterations is bigger than maxiters\nabstol = 0.00001: stop criterion, the optimization is stopped when the loss is lesser than abstol\ncorrection_AIC=true: Bool, do finite samples correction of AIC.\nbeta_penality=2.0 penality  parameters for AIC (or AICc) evaluation.\n\nOutput (if Model_selection =ODE_Model_selection(...):\n\nModel_selection[1] a Matrix containing the loss and the AIC score for each model.\nModel_selection[2] a Tuple containing all the fitted models.\nModel_selection[3] the AIC score of the best model.\nModel_selection[4] , the loss of the best model.\nModel_selection[5] , the parameter of the best model.\nModel_selection[6] , the string of the best model.\nModel_selection[7] , the numerical solution of the fitted ODE.\nThe plot of the  fitting of the best model if save_plot_best_model=true or  display_plot_best_model=true .\n\n\n\n\n\n","category":"function"},{"location":"api/#ODE-Morris-sensitivity","page":"API","title":"ODE Morris sensitivity","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"JMAKi.one_well_morris_sensitivity","category":"page"},{"location":"api/","page":"API","title":"API","text":"JMAKi.one_well_morris_sensitivity","category":"page"},{"location":"api/#JMAKi.one_well_morris_sensitivity","page":"API","title":"JMAKi.one_well_morris_sensitivity","text":"one_well_morris_sensitivity(\ndata::Matrix{Float64},\nname_well::String, \nlabel_exp::String, \nmodel::String,\nlb_param::Vector{Float64}, \nub_param::Vector{Float64};\nN_step_morris=7,\noptmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(), \nintegrator=Tsit5(),\npt_avg=1, \npt_smooth_derivative=7,\nwrite_res=false,\nsmoothing=false, \ntype_of_smoothing=\"lowess\",\ntype_of_loss=\"RE\", \nblank_array=zeros(100), \nmultiple_scattering_correction=false, \nmethod_multiple_scattering_correction=\"interpolation\",\ncalibration_OD_curve=\"NA\", \nPopulationSize=300,\nmaxiters=2000000,\nabstol=0.00001,\n)\n\nThis function is designed to perform Morris sensitivity analysis on a dataset representing the growth curve of a microorganism in a well. It assesses the sensitivity of the model to variations in input parameters of the optimization.\n\nArguments:\n\ndata::Matrix{Float64}: The dataset with the growth curve, where the first row represents times, and the second row represents optical density (OD).\nname_well::String: The name of the well.\nlabel_exp::String: The label of the experiment.\nmodel::String: The ODE model to use.\nlb_param::Vector{Float64}: Lower bounds for the parameters.\nub_param::Vector{Float64}: Upper bounds for the parameters.\n\nKey Arguments:\n\n- `N_step_morris=7`: Number of steps for the Morris sensitivity analysis.\n\nparam= lb_param .+ (ub_param.-lb_param)./2:Vector{Float64}, Initial guess for the model parameters.\n`integrator =Tsit5()' sciML integrator. If using piecewise model please use  'KenCarp4(autodiff=true)'.\noptmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited() optimizer from optimizationBBO.\nsave_plot=false :Bool, save the plot or not.\ndisplay_plots=true:Bool,  Whether or not diplay the plot in julia.\ntype_of_smoothing=\"rolling_avg\": String, How to smooth the data, options: \"NO\" , \"rolling avg\" rolling average of the data, and \"lowess\".\npt_avg=7: Number of points to generate the initial condition or do the rolling avg smoothing.\npt_smoothing_derivative=7:Int,  Number of points for evaluation of specific growth rate. If <2 it uses interpolation algorithm otherwise a sliding window approach.\nsmoothing=false: Whether to apply smoothing to the data or not.\ntype_of_loss:=\"RE\": Type of loss function to be used. (options= \"RE\", \"L2\", \"L2derivative\" and \"blankweighted_L2\").\nblank_array=zeros(100): Data of all blanks in single array.\ncalibration_OD_curve=\"NA\": String, The path where the .csv calibration data are located, used only if multiple_scattering_correction=true.\nmultiple_scattering_correction=false: Bool, if true uses the given calibration curve to correct the data for muliple scattering.\nmethod_multiple_scattering_correction=\"interpolation\": String, How perform the inference of multiple scattering curve, options: \"interpolation\" or   \"exp_fit\" it uses an exponential fit from \"Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications\"\nthr_lowess=0.05: Float64 keyword argument of lowees smoothing\nPopulationSize =100: Size of the population of the optimization\nmaxiters=2000000: stop criterion, the optimization is stopped when the number of iterations is bigger than maxiters\nabstol = 0.00001: stop criterion, the optimization is stopped when the loss is lesser than abstol\n\nOutput (if results_ODE_morris_sensitivity =one_well_morris_sensitivity(...):\n\nresults_ODE_morris_sensitivity[1] a with in each column the initial guess for the parameters of the optimization in the same order of table\nresults_ODE_morris_sensitivity[2] a matrix with the following contents for each column: [\"name of model\", \"well\", \"param_1\",\"param_2\",..,\"param_n\",\"maximum specific gr using ode\",\"maximum specific gr using data\", \"objective function value (i.e. loss of the solution)\"]. It can be saved into a .csv if write_res=true.\n\nwhere ' \"param1\",\"param2\",..,\"paramn\" ' are the parameter of the selected ODE as in this [table](#ODElist)\n\nThe plot of the  fitting of the best model if save_plot_best_model=true or  display_plot_best_model=true .\n\n\n\n\n\n","category":"function"},{"location":"api/#NL-Fitting","page":"API","title":"NL Fitting","text":"","category":"section"},{"location":"api/#NL-Fitting-2","page":"API","title":"NL Fitting","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"JMAKi.fit_NL_model","category":"page"},{"location":"api/","page":"API","title":"API","text":"JMAKi.fit_NL_model","category":"page"},{"location":"api/#JMAKi.fit_NL_model","page":"API","title":"JMAKi.fit_NL_model","text":"fit_NL_model(\ndata::Matrix{Float64}, \nname_well::String,\nlabel_exp::String, \nmodel_function::Any, \nlb_param::Vector{Float64}, \nub_param::Vector{Float64}; \nu0=lb_param .+ (ub_param .- lb_param) ./ 2,\noptmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(),\ndisplay_plots=true, \nsave_plot=false,\npath_to_plot=\"NA\", \npt_avg=1, \npt_smooth_derivative=7,\nsmoothing=false, \ntype_of_smoothing=\"rolling_avg\",\ntype_of_loss=\"RE\", \nmultiple_scattering_correction=false, \nmethod_multiple_scattering_correction=\"interpolation\",\ncalibration_OD_curve=\"NA\",  \nPopulationSize=300,\nmaxiters=2000000,\nabstol=0.00001,\nthr_lowess=0.05,\npenality_CI=3.0,\n)\n\nThis function performs fitting on a single well's data using an any NL function . \n\nArguments:\n\ndata::Matrix{Float64}: The dataset with the growth curve, where the first row represents times, and the second row represents the variable to fit (e.g., OD), see documentation.\nname_well::String: Name of the well.\nlabel_exp::String: Label of the experiment.\nmodel_function::String: The model to use, here put the non linear function desired (see documentations for examples) or the string of one of the hard-coded NL models\nlb_param::Vector{Float64}: Lower bounds of the model parameters.\nub_param::Vector{Float64}: Upper bounds of the model parameters.\n\nKey Arguments:\n\nparam= lb_param .+ (ub_param.-lb_param)./2:Vector{Float64}, Initial guess for the model parameters.\noptmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited() optimizer from optimizationBBO.\nsave_plot=false :Bool, save the plot or not.\ndisplay_plots=true:Bool,  Whether or not diplay the plot in julia.\ntype_of_smoothing=\"rolling_avg\": String, How to smooth the data, options: \"NO\" , \"rolling avg\" rolling average of the data, and \"lowess\".\npt_avg=7: Number of points to generate the initial condition or do the rolling avg smoothing.\nsmoothing=false: Whether to apply smoothing to the data or not.\ntype_of_loss:=\"RE\": Type of loss function to be used. (options= \"RE\", \"L2\", \"L2derivative\" and \"blankweighted_L2\").\nblank_array=zeros(100): Data of all blanks in single array.\npt_smoothing_derivative=7:Int,  Number of points for evaluation of specific growth rate. If <2 it uses interpolation algorithm otherwise a sliding window approach.\ncalibration_OD_curve=\"NA\": String, The path where the .csv calibration data are located, used only if multiple_scattering_correction=true.\nmultiple_scattering_correction=false: Bool, if true uses the given calibration curve to correct the data for muliple scattering.\nmethod_multiple_scattering_correction=\"interpolation\": String, How perform the inference of multiple scattering curve, options: \"interpolation\" or   \"exp_fit\" it uses an exponential fit from \"Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications\"\nthr_lowess=0.05: Float64 keyword argument of lowees smoothing\nPopulationSize =100: Size of the population of the optimization\nmaxiters=2000000: stop criterion, the optimization is stopped when the number of iterations is bigger than maxiters\nabstol = 0.00001: stop criterion, the optimization is stopped when the loss is lesser than abstol\npenality_CI=2.0, used only in segementation to force the optimization to respect continuty on bonduar\n\nOutput (if results_NL_fit =fit_NL_model(...):\n\nresults_NL_fit[1] an array with the following contents: [\"name of model\", \"well\", \"param_1\",\"param_2\",..,\"param_n\",\"maximum specific gr using ode\",\"maximum specific gr using data\", \"objective function value (i.e. loss of the solution)\"] where ' \"param1\",\"param2\",..,\"param_n\" ' are the parameter of the selected model as in the documentation.\nresults_NL_fit[2] the numerical solution of the fitted ODE\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"JMAKi.fit_NL_model_with_sensitivity","category":"page"},{"location":"api/","page":"API","title":"API","text":"JMAKi.fit_NL_model_with_sensitivity","category":"page"},{"location":"api/#JMAKi.fit_NL_model_with_sensitivity","page":"API","title":"JMAKi.fit_NL_model_with_sensitivity","text":"fit_NL_model_with_sensitivity(\ndata::Matrix{Float64}, \nname_well::String,\nlabel_exp::String, \nmodel_function::Any, \nlb_param::Vector{Float64}, \nub_param::Vector{Float64};\nnrep=100,\nu0=lb_param .+ (ub_param .- lb_param) ./ 2,\noptmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(),\ndisplay_plots=true, \nsave_plot=false,\npath_to_plot=\"NA\", \npt_avg=1, \npt_smooth_derivative=7,\nsmoothing=false, \ntype_of_smoothing=\"rolling_avg\",\ntype_of_loss=\"RE\", \nmultiple_scattering_correction=false, \nmethod_multiple_scattering_correction=\"interpolation\",\ncalibration_OD_curve=\"NA\",  \nPopulationSize=300,\nmaxiters=2000000,\nabstol=0.00001,\nthr_lowess=0.05,\npenality_CI=3.0,\n)\n\nThis function performs fitting Morris sensitivity analysis on a single well's data using a NL function. \n\nArguments:\n\ndata::Matrix{Float64}: The dataset with the growth curve, where the first row represents times, and the second row represents the variable to fit (e.g., OD), see documentation.\nname_well::String: Name of the well.\nlabel_exp::String: Label of the experiment.\nmodel_function::String: The model to use, here put the non linear function desired (see documentations for examples) or the string of one of the hard-coded NL models\nlb_param::Vector{Float64}: Lower bounds of the model parameters.\nub_param::Vector{Float64}: Upper bounds of the model parameters.\n\nKey Arguments:\n\nnrep=100. Number of Morris steps.\nparam= lb_param .+ (ub_param.-lb_param)./2:Vector{Float64}, Initial guess for the model parameters.\noptmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited() optimizer from optimizationBBO.\nsave_plot=false :Bool, save the plot or not.\ndisplay_plots=true:Bool,  Whether or not diplay the plot in julia.\ntype_of_smoothing=\"rolling_avg\": String, How to smooth the data, options: \"NO\" , \"rolling avg\" rolling average of the data, and \"lowess\".\npt_avg=7: Number of points to generate the initial condition or do the rolling avg smoothing.\nsmoothing=false: Whether to apply smoothing to the data or not.\ntype_of_loss:=\"RE\": Type of loss function to be used. (options= \"RE\", \"L2\", \"L2derivative\" and \"blankweighted_L2\").\nblank_array=zeros(100): Data of all blanks in single array.\npt_smoothing_derivative=7:Int,  Number of points for evaluation of specific growth rate. If <2 it uses interpolation algorithm otherwise a sliding window approach.\ncalibration_OD_curve=\"NA\": String, The path where the .csv calibration data are located, used only if multiple_scattering_correction=true.\nmultiple_scattering_correction=false: Bool, if true uses the given calibration curve to correct the data for muliple scattering.\nmethod_multiple_scattering_correction=\"interpolation\": String, How perform the inference of multiple scattering curve, options: \"interpolation\" or   \"exp_fit\" it uses an exponential fit from \"Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications\"\nthr_lowess=0.05: Float64 keyword argument of lowees smoothing\nPopulationSize =100: Size of the population of the optimization\nmaxiters=2000000: stop criterion, the optimization is stopped when the number of iterations is bigger than maxiters\nabstol = 0.00001: stop criterion, the optimization is stopped when the loss is lesser than abstol\npenality_CI=2.0, used only in segementation to force the optimization to respect continuty on bonduar\n\nOutput (if results_NL_fit =fit_NL_model_with_sensitivity(...):\n\nresults_NL_fit[1] an array with the following contents: [\"name of model\", \"well\", \"param_1\",\"param_2\",..,\"param_n\",\"maximum specific gr using ode\",\"maximum specific gr using data\", \"objective function value (i.e. loss of the solution)\"] where ' \"param1\",\"param2\",..,\"param_n\" ' are the parameter of the selected model as in the documentation. This for the fit with less loss.\nresults_NL_fit[2]: the parameter of the best fit \nresults_NL_fit[3]: the results of the fit for any combination tested.\n\n-results_NL_fit[4]: the results of the fit for any combination tested.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"JMAKi.fit_NL_model_MCMC_intialization","category":"page"},{"location":"api/","page":"API","title":"API","text":"JMAKi.fit_NL_model_MCMC_intialization","category":"page"},{"location":"api/#JMAKi.fit_NL_model_MCMC_intialization","page":"API","title":"JMAKi.fit_NL_model_MCMC_intialization","text":"fitNLmodelMCMCintialization(     data::Matrix{Float64},      namewell::String,     labelexp::String,      modelfunction::Any,      lbparam::Vector{Float64},      ubparam::Vector{Float64};     nrep=100,     u0=lbparam .+ (ubparam .- lbparam) ./ 2,     optmizator=BBOadaptivederand1binradiuslimited(),     displayplots=true,      saveplot=false,     pathtoplot=\"NA\",      ptavg=1,      ptsmoothderivative=7,     smoothing=false,      typeofsmoothing=\"rollingavg\",     typeofloss=\"RE\",      multiplescatteringcorrection=false,      methodmultiplescatteringcorrection=\"interpolation\",     calibrationODcurve=\"NA\",       PopulationSize=300,     maxiters=2000000,     abstol=0.00001,     thrlowess=0.05,     penality_CI=3.0,     )\n\nThis function performs NL fitting. It tries to automatically detect the optimal starting guess of the parameters by using a Markov Chain Montecarlo restart of the intial guess.\n\nArguments:\n\ndata::Matrix{Float64}: The dataset with the growth curve, where the first row represents times, and the second row represents the variable to fit (e.g., OD), see documentation.\nname_well::String: Name of the well.\nlabel_exp::String: Label of the experiment.\nmodel_function::String: The model to use, here put the non linear function desired (see documentations for examples) or the string of one of the hard-coded NL models\nlb_param::Vector{Float64}: Lower bounds of the model parameters.\nub_param::Vector{Float64}: Upper bounds of the model parameters.\n\nKey Arguments:\n\nnrep=100. Number of MCMC steps.\nparam= lb_param .+ (ub_param.-lb_param)./2:Vector{Float64}, Initial guess for the model parameters.\noptmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited() optimizer from optimizationBBO.\nsave_plot=false :Bool, save the plot or not.\ndisplay_plots=true:Bool,  Whether or not diplay the plot in julia.\ntype_of_smoothing=\"rolling_avg\": String, How to smooth the data, options: \"NO\" , \"rolling avg\" rolling average of the data, and \"lowess\".\npt_avg=7: Number of points to generate the initial condition or do the rolling avg smoothing.\nsmoothing=false: Whether to apply smoothing to the data or not.\ntype_of_loss:=\"RE\": Type of loss function to be used. (options= \"RE\", \"L2\", \"L2derivative\" and \"blankweighted_L2\").\nblank_array=zeros(100): Data of all blanks in single array.\npt_smoothing_derivative=7:Int,  Number of points for evaluation of specific growth rate. If <2 it uses interpolation algorithm otherwise a sliding window approach.\ncalibration_OD_curve=\"NA\": String, The path where the .csv calibration data are located, used only if multiple_scattering_correction=true.\nmultiple_scattering_correction=false: Bool, if true uses the given calibration curve to correct the data for muliple scattering.\nmethod_multiple_scattering_correction=\"interpolation\": String, How perform the inference of multiple scattering curve, options: \"interpolation\" or   \"exp_fit\" it uses an exponential fit from \"Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications\"\nthr_lowess=0.05: Float64 keyword argument of lowees smoothing\nPopulationSize =100: Size of the population of the optimization\nmaxiters=2000000: stop criterion, the optimization is stopped when the number of iterations is bigger than maxiters\nabstol = 0.00001: stop criterion, the optimization is stopped when the loss is lesser than abstol\npenality_CI=2.0, used only in segementation to force the optimization to respect continuty on bonduar\n\nOutput (if results_NL_fit =fit_NL_model_MCMC_intialization(...):\n\nresults_NL_fit[1] an array with the following contents: [\"name of model\", \"well\", \"param_1\",\"param_2\",..,\"param_n\",\"maximum specific gr using ode\",\"maximum specific gr using data\", \"objective function value (i.e. loss of the solution)\"] where ' \"param1\",\"param2\",..,\"param_n\" ' are the parameter of the selected model as in the documentation. This for the fit with less loss.\nresults_NL_fit[2]: the array of the best fit \nresults_NL_fit[3]: the chain of all proposed solutions losses\n\n-results_NL_fit[4]: the chain of the best losses\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"JMAKi.fit_NL_model_bootstrap","category":"page"},{"location":"api/","page":"API","title":"API","text":"JMAKi.fit_NL_model_bootstrap","category":"page"},{"location":"api/#JMAKi.fit_NL_model_bootstrap","page":"API","title":"JMAKi.fit_NL_model_bootstrap","text":"fitNLmodelbootstrap(     data::Matrix{Float64},      namewell::String,     labelexp::String,      modelfunction::Any,      lbparam::Vector{Float64},      ubparam::Vector{Float64};     nrep=100,     u0=lbparam .+ (ubparam .- lbparam) ./ 2,     optmizator=BBOadaptivederand1binradiuslimited(),     displayplots=true,      saveplot=false,     pathtoplot=\"NA\",      ptavg=1,      sizebootstrap=0.7,     ptsmoothderivative=7,     smoothing=false,      typeofsmoothing=\"rollingavg\",     typeofloss=\"RE\",      multiplescatteringcorrection=false,      methodmultiplescatteringcorrection=\"interpolation\",     calibrationODcurve=\"NA\",       PopulationSize=300,     maxiters=2000000,     abstol=0.00001,     thrlowess=0.05,     penality_CI=3.0,     )\n\nThis function performs NL fitting. It perform nrep iterations of Bootstrap to evaluate the confidence intervals and  avoid bad initializations.\n\ndata::Matrix{Float64}: The dataset with the growth curve, where the first row represents times, and the second row represents the variable to fit (e.g., OD), see documentation.\nname_well::String: Name of the well.\nlabel_exp::String: Label of the experiment.\nmodel_function::String: The model to use, here put the non linear function desired (see documentations for examples) or the string of one of the hard-coded NL models\nlb_param::Vector{Float64}: Lower bounds of the model parameters.\nub_param::Vector{Float64}: Upper bounds of the model parameters.\n\nKey Arguments:\n\nsize_bootstrap=0.7: Float, the fraction of data used each Bootstrap run\nnrep=100. Number of MCMC steps.\nparam= lb_param .+ (ub_param.-lb_param)./2:Vector{Float64}, Initial guess for the model parameters.\noptmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited() optimizer from optimizationBBO.\nsave_plot=false :Bool, save the plot or not.\ndisplay_plots=true:Bool,  Whether or not diplay the plot in julia.\ntype_of_smoothing=\"rolling_avg\": String, How to smooth the data, options: \"NO\" , \"rolling avg\" rolling average of the data, and \"lowess\".\npt_avg=7: Number of points to generate the initial condition or do the rolling avg smoothing.\nsmoothing=false: Whether to apply smoothing to the data or not.\ntype_of_loss:=\"RE\": Type of loss function to be used. (options= \"RE\", \"L2\", \"L2derivative\" and \"blankweighted_L2\").\nblank_array=zeros(100): Data of all blanks in single array.\npt_smoothing_derivative=7:Int,  Number of points for evaluation of specific growth rate. If <2 it uses interpolation algorithm otherwise a sliding window approach.\ncalibration_OD_curve=\"NA\": String, The path where the .csv calibration data are located, used only if multiple_scattering_correction=true.\nmultiple_scattering_correction=false: Bool, if true uses the given calibration curve to correct the data for muliple scattering.\nmethod_multiple_scattering_correction=\"interpolation\": String, How perform the inference of multiple scattering curve, options: \"interpolation\" or   \"exp_fit\" it uses an exponential fit from \"Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications\"\nthr_lowess=0.05: Float64 keyword argument of lowees smoothing\nPopulationSize =100: Size of the population of the optimization\nmaxiters=2000000: stop criterion, the optimization is stopped when the number of iterations is bigger than maxiters\nabstol = 0.00001: stop criterion, the optimization is stopped when the loss is lesser than abstol\npenality_CI=2.0, used only in segementation to force the optimization to respect continuty on bonduar\n\nOutput (if results_NL_fit =fit_NL_model_bootstrap(...):\n\nresults_NL_fit[1] an array with the following contents: [\"name of model\", \"well\", \"param_1\",\"param_2\",..,\"param_n\",\"maximum specific gr using ode\",\"maximum specific gr using data\", \"objective function value (i.e. loss of the solution)\"] where ' \"param1\",\"param2\",..,\"param_n\" ' are the parameter of the selected model as in the documentation. This for the fit with less loss.\nresults_NL_fit[2]: the array of the best fit \nresults_NL_fit[3]:parameters \n\n-results_NL_fit[4]: parameters -results_NL_fit[5]: mean best parameters -results_NL_fit[6]: std best parameters -results_NL_fit[7]:CI lower bound -results_NL_fit[8]:CI upper bound\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"JMAKi.NL_error_blanks","category":"page"},{"location":"api/","page":"API","title":"API","text":"JMAKi.NL_error_blanks","category":"page"},{"location":"api/#JMAKi.NL_error_blanks","page":"API","title":"JMAKi.NL_error_blanks","text":"NL_error_blanks(data::Matrix{Float64}, \nname_well::String, \nlabel_exp::String, \nmodel_function::Any,\nlb_param::Vector{Float64},\nub_param::Vector{Float64},\nblank_array::Vector{Float64}; \nnrep=100,\nu0=lb_param .+ (ub_param .- lb_param) ./ 2,\noptmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(),\ndisplay_plots=false, \nsave_plot=false,\npath_to_plot=\"NA\", \npt_avg=1, \npt_smooth_derivative=7,\nsmoothing=false,\ntype_of_smoothing=\"rolling_avg\",\ntype_of_loss=\"RE\", \nmultiple_scattering_correction=false,\nmethod_multiple_scattering_correction=\"interpolation\",\ncalibration_OD_curve=\"NA\",  \nPopulationSize=300,\nmaxiters=2000000,\nabstol=0.00001,\nthr_lowess=0.05,\nwrite_res=false,\npenality_CI=3.0\n)\n\nThis function performs NL fitting. It perform nrep iterations to estimate the posterior distribuition of parameters fitting. It uses the blank distribution as noise.\n\ndata::Matrix{Float64}: The dataset with the growth curve, where the first row represents times, and the second row represents the variable to fit (e.g., OD), see documentation.\nname_well::String: Name of the well.\nlabel_exp::String: Label of the experiment.\nmodel_function::String: The model to use, here put the non linear function desired (see documentations for examples) or the string of one of the hard-coded NL models\nlb_param::Vector{Float64}: Lower bounds of the model parameters.\nub_param::Vector{Float64}: Upper bounds of the model parameters.\n\nKey Arguments:\n\nnrep=100. Number of MCMC steps.\nparam= lb_param .+ (ub_param.-lb_param)./2:Vector{Float64}, Initial guess for the model parameters.\noptmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited() optimizer from optimizationBBO.\nsave_plot=false :Bool, save the plot or not.\ndisplay_plots=true:Bool,  Whether or not diplay the plot in julia.\ntype_of_smoothing=\"rolling_avg\": String, How to smooth the data, options: \"NO\" , \"rolling avg\" rolling average of the data, and \"lowess\".\npt_avg=7: Number of points to generate the initial condition or do the rolling avg smoothing.\nsmoothing=false: Whether to apply smoothing to the data or not.\ntype_of_loss:=\"RE\": Type of loss function to be used. (options= \"RE\", \"L2\", \"L2derivative\" and \"blankweighted_L2\").\nblank_array=zeros(100): Data of all blanks in single array.\npt_smoothing_derivative=7:Int,  Number of points for evaluation of specific growth rate. If <2 it uses interpolation algorithm otherwise a sliding window approach.\ncalibration_OD_curve=\"NA\": String, The path where the .csv calibration data are located, used only if multiple_scattering_correction=true.\nmultiple_scattering_correction=false: Bool, if true uses the given calibration curve to correct the data for muliple scattering.\nmethod_multiple_scattering_correction=\"interpolation\": String, How perform the inference of multiple scattering curve, options: \"interpolation\" or   \"exp_fit\" it uses an exponential fit from \"Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications\"\nthr_lowess=0.05: Float64 keyword argument of lowees smoothing\nPopulationSize =100: Size of the population of the optimization\nmaxiters=2000000: stop criterion, the optimization is stopped when the number of iterations is bigger than maxiters\nabstol = 0.00001: stop criterion, the optimization is stopped when the loss is lesser than abstol\npenality_CI=2.0, used only in segementation to force the optimization to respect continuty on bonduar\n\nOutput (if results_NL_fit =NL_error_blanks(...):\n\nresults_NL_fit[1] an array with the following contents: [\"name of model\", \"well\", \"param_1\",\"param_2\",..,\"param_n\",\"maximum specific gr using ode\",\"maximum specific gr using data\", \"objective function value (i.e. loss of the solution)\"] where ' \"param1\",\"param2\",..,\"param_n\" ' are the parameter of the selected model as in the documentation. This for the fit with less loss.\nresults_NL_fit[2]: the array of the best fit \nresults_NL_fit[3]:parameters \n\n-results_NL_fit[4]: parameters -results_NL_fit[5]: mean best parameters -results_NL_fit[6]: std best parameters -results_NL_fit[7]:CI lower bound -results_NL_fit[8]:CI upper bound\n\n\n\n\n\n","category":"function"},{"location":"api/#NL-Model-selection","page":"API","title":"NL Model selection","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"JMAKi.NL_model_selection","category":"page"},{"location":"api/","page":"API","title":"API","text":"JMAKi.NL_model_selection","category":"page"},{"location":"api/#JMAKi.NL_model_selection","page":"API","title":"JMAKi.NL_model_selection","text":"NL_model_selection(data::Matrix{Float64}, \nname_well::String,\nlabel_exp::String, \nlist_model_function::Any, \nlist_lb_param::Any, \nlist_ub_param::Any; \nmethod_of_fitting=\"MCMC\",\nnrep=100,\nlist_u0=list_lb_param .+ (list_ub_param .- list_lb_param) ./ 2,\noptmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(),\ndisplay_plots=true, \nsave_plot=false,\nsize_bootstrap=0.7,\npath_to_plot=\"NA\",\npt_avg=1,\npt_smooth_derivative=7,\nsmoothing=false, \ntype_of_smoothing=\"rolling_avg\",\ntype_of_loss=\"RE\", \nmultiple_scattering_correction=false, \nmethod_multiple_scattering_correction=\"interpolation\",\ncalibration_OD_curve=\"NA\",  \nPopulationSize=300,\nmaxiters=2000000,\nabstol=0.00001,\nthr_lowess=0.05,\nwrite_res=false,\nbeta_param=2.0,\npenality_CI=8.0,\ncorrection_AIC=false,\n)\n\nThis function performs NL model selection of an array of NL models, it uses AIC or AICc depending on user inputs. It perform nrep iterations to estimate the posterior distribuition of parameters fitting. It uses the blank distribution as noise.\n\ndata::Matrix{Float64}: The dataset with the growth curve, where the first row represents times, and the second row represents the variable to fit (e.g., OD), see documentation.\nname_well::String: Name of the well.\nlabel_exp::String: Label of the experiment.\nlist_model_function::Any: Array containing functions or strings of the NL models\nlist_lb_param::Any:Array of Lower bounds for the parameters (compatible with the models).\nlist_ub_param::Any:Array of Upper bounds for the parameters (compatible with the models).\n\nKey Arguments:\n\nmethod_of_fitting=\"MCMC\": String, how perform the NL fit. Options \"MCMC\",\"Bootstrap\",\"Normal\", and \"Morris_sensitivity\"\nnrep=100. Number of MCMC steps.\nparam= lb_param .+ (ub_param.-lb_param)./2:Vector{Float64}, Initial guess for the model parameters.\noptmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited() optimizer from optimizationBBO.\nsave_plot=false :Bool, save the plot or not.\ndisplay_plots=true:Bool,  Whether or not diplay the plot in julia.\ntype_of_smoothing=\"rolling_avg\": String, How to smooth the data, options: \"NO\" , \"rolling avg\" rolling average of the data, and \"lowess\".\npt_avg=7: Number of points to generate the initial condition or do the rolling avg smoothing.\nsmoothing=false: Whether to apply smoothing to the data or not.\ntype_of_loss:=\"RE\": Type of loss function to be used. (options= \"RE\", \"L2\", \"L2derivative\" and \"blankweighted_L2\").\nblank_array=zeros(100): Data of all blanks in single array.\npt_smoothing_derivative=7:Int,  Number of points for evaluation of specific growth rate. If <2 it uses interpolation algorithm otherwise a sliding window approach.\ncalibration_OD_curve=\"NA\": String, The path where the .csv calibration data are located, used only if multiple_scattering_correction=true.\nmultiple_scattering_correction=false: Bool, if true uses the given calibration curve to correct the data for muliple scattering.\nmethod_multiple_scattering_correction=\"interpolation\": String, How perform the inference of multiple scattering curve, options: \"interpolation\" or   \"exp_fit\" it uses an exponential fit from \"Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications\"\nthr_lowess=0.05: Float64 keyword argument of lowees smoothing\nPopulationSize =100: Size of the population of the optimization\nmaxiters=2000000: stop criterion, the optimization is stopped when the number of iterations is bigger than maxiters\nabstol = 0.00001: stop criterion, the optimization is stopped when the loss is lesser than abstol\npenality_CI=2.0, used only in segementation to force the optimization to respect continuty on bonduar\ncorrection_AIC=true: Bool, do finite samples correction of AIC.\nbeta_param=2.0 penality  parameters for AIC (or AICc) evaluation.\nsize_bootstrap=0.7: Float, the fraction of data used each Bootstrap run. Used only if method is \"Bootstrap\"\n\nOutput (if results_NL_fit =NL_model_selection(...):\n\nresults_NL_fit[1] an array with the following contents: [\"name of model\", \"well\", \"param_1\",\"param_2\",..,\"param_n\",\"maximum specific gr using ode\",\"maximum specific gr using data\", \"objective function value (i.e. loss of the solution)\"] where ' \"param1\",\"param2\",..,\"param_n\" ' are the parameter of the selected model as in the documentation. This for the fit with less loss.\nresults_NL_fit[2]: an array with the following contents: [\"name of model\", \"well\", \"param_1\",\"param_2\",..,\"param_n\",\"maximum specific gr using ode\",\"maximum specific gr using data\", \"objective function value (i.e. loss of the solution)\"] where ' \"param1\",\"param2\",..,\"param_n\" ' are the parameter of the selected model as in the documentation. This for the fit with less loss.\nresults_NL_fit[3]: the array of best fit \n\n-results_NL_fit[4]: scores of the models -results_NL_fit[5]: the loss of the best loss\n\n\n\n\n\n","category":"function"},{"location":"api/#Segmented-fitting","page":"API","title":"Segmented fitting","text":"","category":"section"},{"location":"api/#ODE-segmentation","page":"API","title":"ODE segmentation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"JMAKi.selection_ODE_fixed_intervals","category":"page"},{"location":"api/","page":"API","title":"API","text":"JMAKi.selection_ODE_fixed_intervals","category":"page"},{"location":"api/#JMAKi.selection_ODE_fixed_intervals","page":"API","title":"JMAKi.selection_ODE_fixed_intervals","text":"selection_ODE_fixed_intervals(\ndata_testing::Matrix{Float64}, \nname_well::String, \nlabel_exp::String, \nlist_of_models::Vector{String}, \nlist_lb_param::Any, \nlist_ub_param::Any, \nintervals_changepoints::Any;\ntype_of_loss=\"L2\", \noptmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(), \nintegrator=Tsit5(), \nsmoothing=false,\ntype_of_smoothing=\"lowess\",\nthr_lowess=0.05,\npt_avg=1,\nsave_plot=false, \ndisplay_plots=false,\npath_to_plot=\"NA\", \npt_smooth_derivative=7,\nmultiple_scattering_correction=false, \nmethod_multiple_scattering_correction=\"interpolation\",\ncalibration_OD_curve=\"NA\", \nbeta_smoothing_ms=2.0, \nPopulationSize=300,\nmaxiters=2000000,\nabstol=0.0000000001,\ncorrection_AIC=true)\n\nThis function performs a fitting of a segmented ODE on one curve. For this function the user must supply the change points.\n\nArguments:\n\ndata_testing::Matrix{Float64}: The dataset with the growth curve, where the first row represents times, and the second row represents optical density (OD).\nname_well::String: The name of the well.\nlabel_exp::String: The label of the experiment.\nlist_of_models::Vector{String}: A vector of string of ODE models to evaluate.\nlist_lb_param::Any: Lower bounds for the parameters (compatible with the models).\nlist_ub_param::Any: Upper bounds for the parameters (compatible with the models).\nintervals_changepoints::Any: the array containings the change point list, e.g., [0.0 10.0 30.0] \n\nKey Arguments:\n\nparam= lb_param .+ (ub_param.-lb_param)./2:Vector{Float64}, Initial guess for the model parameters.\n`integrator =Tsit5()' sciML integrator. If using piecewise model please use  'KenCarp4(autodiff=true)'.\noptmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited() optimizer from optimizationBBO.\nsave_plot_best_model=false :Bool, save the plot or not.\ndisplay_plot_best_model=true:Bool,  Whether or not diplay the plot in julia.\ntype_of_smoothing=\"rolling_avg\": String, How to smooth the data, options: \"NO\" , \"rolling avg\" rolling average of the data, and \"lowess\".\npt_avg=7: Number of points to generate the initial condition or do the rolling avg smoothing.\npt_smoothing_derivative=7:Int,  Number of points for evaluation of specific growth rate. If <2 it uses interpolation algorithm otherwise a sliding window approach.\nsmoothing=false: Whether to apply smoothing to the data or not.\ntype_of_loss:=\"RE\": Type of loss function to be used. (options= \"RE\", \"L2\", \"L2derivative\" and \"blankweighted_L2\").\nblank_array=zeros(100): Data of all blanks in single array.\ncalibration_OD_curve=\"NA\": String, The path where the .csv calibration data are located, used only if multiple_scattering_correction=true.\nmultiple_scattering_correction=false: Bool, if true uses the given calibration curve to correct the data for muliple scattering.\nmethod_multiple_scattering_correction=\"interpolation\": String, How perform the inference of multiple scattering curve, options: \"interpolation\" or   \"exp_fit\" it uses an exponential fit from \"Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications\"\nthr_lowess=0.05: Float64 keyword argument of lowees smoothing\nPopulationSize =100: Size of the population of the optimization\nmaxiters=2000000: stop criterion, the optimization is stopped when the number of iterations is bigger than maxiters\nabstol = 0.00001: stop criterion, the optimization is stopped when the loss is lesser than abstol\ncorrection_AIC=true: Bool, do finite samples correction of AIC.\nbeta_penality=2.0 penality  parameters for AIC (or AICc) evaluation.\n\nOutput (if res =selection_ODE_fixed_intervals(...):\n\nres[1]. Parameters of each segment\nres[2]. Interval of the ODE segment\nres[3]. Time of the fitted solution\nres[4]. Numerical fitted solution\nres[5]. the loss of the solution\nThe plot of the  fitting of the best model if save_plot_best_model=true or  display_plot_best_model=true .\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"JMAKi.segmentation_ODE","category":"page"},{"location":"api/","page":"API","title":"API","text":"JMAKi.segmentation_ODE","category":"page"},{"location":"api/#JMAKi.segmentation_ODE","page":"API","title":"JMAKi.segmentation_ODE","text":"segmentation_ODE(\ndata_testing::Matrix{Float64}, \nname_well::String, \nlabel_exp::String, \nlist_of_models::Vector{String}, \nlist_lb_param::Any,\nlist_ub_param::Any,\nn_max_change_points::Int;\ndetect_number_cpd=true,\nfixed_cpd=false,\noptmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(),\nintegrator=Tsit5(),\ntype_of_loss=\"L2\",\ntype_of_detection=\"slinding_win\",\ntype_of_curve=\"original\",\npt_avg=1, \nsmoothing=true, \nsave_plot=false, \ndisplay_plot=false,\npath_to_plot=\"NA\", \npath_to_results=\"NA\",\nwin_size=14, \npt_smooth_derivative=7,\npenality_parameter=2.0,\nmultiple_scattering_correction=false, \nmethod_multiple_scattering_correction=\"interpolation\",\ncalibration_OD_curve=\"NA\",  \nsave_all_model=false,\nmethod_peaks_detection=\"peaks_prominence\",\nn_bins=40,\nPopulationSize=300,\nmaxiters=2000000,\nabstol=0.00001,\ntype_of_smoothing=\"lowess\",\nthr_lowess=0.05,\ncorrection_AIC=true)\n\nThis function performs model selection for ordinary differential equation (ODE) models while segmenting the time series in various part using change points detection algorithm.\n\nArguments:\n\ndata_testing::Matrix{Float64}: The dataset with the growth curve, where the first row represents times, and the second row represents optical density (OD).\nname_well::String: The name of the well.\nlabel_exp::String: The label of the experiment.\nlist_of_models::Vector{String}: A vector of ODE models to evaluate.\nlist_lb_param::Any: Array of lower bounds for the parameters of all models.\nlist_ub_param::Any: Array of upper bounds for the parameters of all models.\nn_max_change_points::Int: Number of change point used, the results will have different number of cp depending on the values of key argument 'typeofdetection' and 'fixed_cpd'\n\nKey Arguments:\n\n`integrator =Tsit5()' sciML integrator. If using piecewise model please use  'KenCarp4(autodiff=true)'.\noptmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited() optimizer from optimizationBBO.\nsave_plot_best_model=false :Bool, save the plot or not.\ndisplay_plot_best_model=true:Bool,  Whether or not diplay the plot in julia.\ntype_of_smoothing=\"rolling_avg\": String, How to smooth the data, options: \"NO\" , \"rolling avg\" rolling average of the data, and \"lowess\".\npt_avg=7: Number of points to generate the initial condition or do the rolling avg smoothing.\npt_smoothing_derivative=7:Int,  Number of points for evaluation of specific growth rate. If <2 it uses interpolation algorithm otherwise a sliding window approach.\nsmoothing=false: Whether to apply smoothing to the data or not.\ntype_of_loss:=\"RE\": Type of loss function to be used. (options= \"RE\", \"L2\", \"L2derivative\" and \"blankweighted_L2\").\nblank_array=zeros(100): Data of all blanks in single array.\ncalibration_OD_curve=\"NA\": String, The path where the .csv calibration data are located, used only if multiple_scattering_correction=true.\nmultiple_scattering_correction=false: Bool, if true uses the given calibration curve to correct the data for muliple scattering.\nmethod_multiple_scattering_correction=\"interpolation\": String, How perform the inference of multiple scattering curve, options: '\"interpolation\"' or   '\"exp_fit\"' it uses an exponential fit from \"Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications\"\nthr_lowess=0.05: Float64 keyword argument of lowees smoothing\nPopulationSize =100: Size of the population of the optimization\nmaxiters=2000000: stop criterion, the optimization is stopped when the number of iterations is bigger than maxiters\nabstol = 0.00001: stop criterion, the optimization is stopped when the loss is lesser than abstol\ncorrection_AIC=true: Bool, do finite samples correction of AIC.\nbeta_penality=2.0 penality  parameters for AIC (or AICc) evaluation.\n'typeofdetection=\"slindingwin\"': String, algorithm of cpd to use. Options '\"slindingwin\"' use a slinding window approach, '\"lsdd\"' uses least square density difference (LSDD) from ChangePointDetection.jl \n'typeofcurve=\"original\"': String, on which curve is performed the change point detection algorithm. If '\"original\"' it use the original time series. With '\"deriv\"' it use the specific growth rate time series to perform the cdp.\nmethod_peaks_detection=\"peaks_prominence\": How the peak detection is performed on the dissimilarity curve.  \"peaks_prominence\" orders the peaks by prominence. thr_scan uses a threshold to choose the peaks\nn_bins=40: Int, used if method_peaks_detection=\"thr_scan\" number of bins used to generate the threshold that has nchangepoints peaks\n'detectnumbercpd=true': Bool, if equal to true all the possible combination of lenght 1,2,...,nchangepoints are tested and the best for AICc is returned.\n'fixedcpd=false': Bool If  true it returns the fitting using top nchange_points.\n'win_size=14': Int, size of the windows used by the cdo algorithms\n'pathtoresults=\"NA\"':String, where to save the results.\n'saveallmodel=false': Bool, if true all the tested model are saved.\n\nNote that, if 'detectnumbercpd=false' and 'fixedcpd=false' JMAKi will use nchangepoints but it will test different combinations of the nchange_points+2 top change points\n\nOutput (if Model_selection =ODE_Model_selection(...):\n\nres[1]. Parameters of each segment\nres[2]. Interval of the ODE segment\nres[3]. Time of the fitted solution\nres[4]. Numerical fitted solution\nThe plot of the  fitting of the best model if save_plot_best_model=true or  display_plot_best_model=true .\n\n\n\n\n\n","category":"function"},{"location":"api/#NL-segmentation","page":"API","title":"NL segmentation","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"JMAKi.selection_NL_fixed_interval","category":"page"},{"location":"api/","page":"API","title":"API","text":"JMAKi.selection_NL_fixed_interval","category":"page"},{"location":"api/#JMAKi.selection_NL_fixed_interval","page":"API","title":"JMAKi.selection_NL_fixed_interval","text":"selection_NL_fixed_interval(\ndata_testing::Matrix{Float64},\nname_well::String, \nlabel_exp::String, \nlist_of_models::Vector{String}, \nlist_lb_param::Any, \nlist_ub_param::Any, \nintervals_changepoints::Any;\nlist_u0=list_lb_param .+ (list_ub_param .- list_lb_param) ./ 2,\ntype_of_loss=\"L2\", \noptmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(),\nmethod_of_fitting=\"MCMC\",\nsmoothing=false,\nsize_bootstrap=0.7,\nnrep=100,\ntype_of_smoothing=\"lowess\",\nthr_lowess=0.05,\npt_avg=1,\npt_smooth_derivative=0,\nmultiple_scattering_correction=false, \nmethod_multiple_scattering_correction=\"interpolation\",\ncalibration_OD_curve=\"NA\", \nbeta_smoothing_ms=2.0,\nPopulationSize=300,\nmaxiters=2000000,\nabstol=0.000000001,\npenality_CI=8.0,\ncorrection_AIC=true,\n)\n\n\n\nThis function performs a fitting of a segmented NL on one curve. For this function the user must supply the change points.\n\ndata::Matrix{Float64}: The dataset with the growth curve, where the first row represents times, and the second row represents the variable to fit (e.g., OD), see documentation.\nname_well::String: Name of the well.\nlabel_exp::String: Label of the experiment.\nlist_model_function::Any: Array containing functions or strings of the NL models\nlist_lb_param::Any:Array of Lower bounds for the parameters (compatible with the models).\nlist_ub_param::Any:Array of Upper bounds for the parameters (compatible with the models).\nmodels_list::Vector{String}: Array of  models to evaluate.\nintervals_changepoints::Any: the array containings the change point list, e.g., [0.0 10.0 30.0] \n\nKey Arguments:\n\nmethod_of_fitting=\"MCMC\": String, how perform the NL fit. Options \"MCMC\",\"Bootstrap\",\"Normal\", and \"Morris_sensitivity\"\nnrep=100. Number of MCMC steps.\nparam= lb_param .+ (ub_param.-lb_param)./2:Vector{Float64}, Initial guess for the model parameters.\noptmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited() optimizer from optimizationBBO.\nsave_plot=false :Bool, save the plot or not.\ndisplay_plots=true:Bool,  Whether or not diplay the plot in julia.\ntype_of_smoothing=\"rolling_avg\": String, How to smooth the data, options: \"NO\" , \"rolling avg\" rolling average of the data, and \"lowess\".\npt_avg=7: Number of points to generate the initial condition or do the rolling avg smoothing.\nsmoothing=false: Whether to apply smoothing to the data or not.\ntype_of_loss:=\"RE\": Type of loss function to be used. (options= \"RE\", \"L2\", \"L2derivative\" and \"blankweighted_L2\").\nblank_array=zeros(100): Data of all blanks in single array.\npt_smoothing_derivative=7:Int,  Number of points for evaluation of specific growth rate. If <2 it uses interpolation algorithm otherwise a sliding window approach.\ncalibration_OD_curve=\"NA\": String, The path where the .csv calibration data are located, used only if multiple_scattering_correction=true.\nmultiple_scattering_correction=false: Bool, if true uses the given calibration curve to correct the data for muliple scattering.\nmethod_multiple_scattering_correction=\"interpolation\": String, How perform the inference of multiple scattering curve, options: \"interpolation\" or   \"exp_fit\" it uses an exponential fit from \"Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications\"\nthr_lowess=0.05: Float64 keyword argument of lowees smoothing\nPopulationSize =100: Size of the population of the optimization\nmaxiters=2000000: stop criterion, the optimization is stopped when the number of iterations is bigger than maxiters\nabstol = 0.00001: stop criterion, the optimization is stopped when the loss is lesser than abstol\npenality_CI=2.0, used only in segementation to force the optimization to respect continuty on bonduar\ncorrection_AIC=true: Bool, do finite samples correction of AIC.\nbeta_param=2.0 penality  parameters for AIC (or AICc) evaluation.\nsize_bootstrap=0.7: Float, the fraction of data used each Bootstrap run. Used only if method is \"Bootstrap\"\n\nOutput (if results_NL_fit =selection_NL_fixed_interval(...):\n\nresults_NL_fit[1]. Parameters of each segment\nresults_NL_fit[2]. The numerical solutions of the fit\nresults_NL_fit[3].  The time of the numerical solutions of the fit\nresults_NL_fit[4]. the loss of the best loss\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"JMAKi.selection_NL_max_change_points","category":"page"},{"location":"api/","page":"API","title":"API","text":"JMAKi.selection_NL_max_change_points","category":"page"},{"location":"api/#JMAKi.selection_NL_max_change_points","page":"API","title":"JMAKi.selection_NL_max_change_points","text":"selection_NL_max_change_points(\ndata_testing::Matrix{Float64},\nname_well::String, \nlabel_exp::String,\nlist_of_models::Any, \nlist_lb_param::Any, \nlist_ub_param::Any, \nn_change_points::Int;\nlist_u0=list_lb_param .+ (list_ub_param .- list_lb_param) ./ 2,\ntype_of_loss=\"L2_fixed_CI\", \noptmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(),\nmethod_of_fitting=\"MCMC\", \ntype_of_detection=\"sliding_win\",\ntype_of_curve=\"original\",\nsmoothing=false,\nnrep=100,\ntype_of_smoothing=\"lowess\",\nthr_lowess=0.05,\npt_avg=1,\nsave_plot=false,\ndisplay_plots=false,\npath_to_plot=\"NA\", \nwin_size=7, \npt_smooth_derivative=0,\nmultiple_scattering_correction=false,\nmethod_multiple_scattering_correction=\"interpolation\",\ncalibration_OD_curve=\"NA\", \nbeta_smoothing_ms=2.0, \nmethod_peaks_detection=\"peaks_prominence\",\nn_bins=40,\nPopulationSize=300,\nmaxiters=2000000,\nabstol=0.000000001,\ndetect_number_cpd=false,\nfixed_cpd=false,\npenality_CI=8.0,\nsize_bootstrap=0.7,\ncorrection_AIC=true\n)\n\nThis function performs model selection for NL models while segmenting the time series in various part using change points detection algorithm.\n\ndata::Matrix{Float64}: The dataset with the growth curve, where the first row represents times, and the second row represents the variable to fit (e.g., OD), see documentation.\nname_well::String: Name of the well.\nlabel_exp::String: Label of the experiment.\nlist_model_function::Any: Array containing functions or strings of the NL models\nlist_lb_param::Any:Array of Lower bounds for the parameters (compatible with the models).\nlist_ub_param::Any:Array of Upper bounds for the parameters (compatible with the models).\nmodels_list::Vector{String}: Array of  models to evaluate.\nintervals_changepoints::Any: the array containings the change point list, e.g., [0.0 10.0 30.0] \n\nKey Arguments:\n\nmethod_of_fitting=\"MCMC\": String, how perform the NL fit. Options \"MCMC\",\"Bootstrap\",\"Normal\", and \"Morris_sensitivity\"\nnrep=100. Number of MCMC steps.\nparam= lb_param .+ (ub_param.-lb_param)./2:Vector{Float64}, Initial guess for the model parameters.\noptmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited() optimizer from optimizationBBO.\nsave_plot=false :Bool, save the plot or not.\ndisplay_plots=true:Bool,  Whether or not diplay the plot in julia.\ntype_of_smoothing=\"rolling_avg\": String, How to smooth the data, options: \"NO\" , \"rolling avg\" rolling average of the data, and \"lowess\".\npt_avg=7: Number of points to generate the initial condition or do the rolling avg smoothing.\nsmoothing=false: Whether to apply smoothing to the data or not.\ntype_of_loss:=\"RE\": Type of loss function to be used. (options= \"RE\", \"L2\", \"L2derivative\" and \"blankweighted_L2\").\nblank_array=zeros(100): Data of all blanks in single array.\npt_smoothing_derivative=7:Int,  Number of points for evaluation of specific growth rate. If <2 it uses interpolation algorithm otherwise a sliding window approach.\ncalibration_OD_curve=\"NA\": String, The path where the .csv calibration data are located, used only if multiple_scattering_correction=true.\nmultiple_scattering_correction=false: Bool, if true uses the given calibration curve to correct the data for muliple scattering.\nmethod_multiple_scattering_correction=\"interpolation\": String, How perform the inference of multiple scattering curve, options: \"interpolation\" or   \"exp_fit\" it uses an exponential fit from \"Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications\"\nthr_lowess=0.05: Float64 keyword argument of lowees smoothing\nPopulationSize =100: Size of the population of the optimization\nmaxiters=2000000: stop criterion, the optimization is stopped when the number of iterations is bigger than maxiters\nabstol = 0.00001: stop criterion, the optimization is stopped when the loss is lesser than abstol\npenality_CI=2.0, used only in segementation to force the optimization to respect continuty on bonduar\ncorrection_AIC=true: Bool, do finite samples correction of AIC.\nbeta_param=2.0 penality  parameters for AIC (or AICc) evaluation.\nsize_bootstrap=0.7: Float, the fraction of data used each Bootstrap run. Used only if method is \"Bootstrap\"\n\nOutput (if results_NL_fit =selection_NL_fixed_interval(...):\n\nresults_NL_fit[1] an array with the following the parameters of each segment\nresults_NL_fit[2]: the list of used change points\nresults_NL_fit[3]:the numerical best solution\n\n-results_NL_fit[4]: the time of the numerical best solution\n\n\n\n\n\n","category":"function"},{"location":"api/#Plot-a-file","page":"API","title":"Plot a file","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"JMAKi.plot_data","category":"page"},{"location":"api/","page":"API","title":"API","text":"JMAKi.plot_data","category":"page"},{"location":"api/#JMAKi.plot_data","page":"API","title":"JMAKi.plot_data","text":"plot_data(\nlabel_exp::String, \npath_to_data::String; \npath_to_annotation::Any = missing,\npath_to_plot=\"NA\",\ndisplay_plots=true,\nsave_plots=false,\noverlay_plots=true, \ndo_blank_subtraction=\"NO\", vg)\navg_replicate=false, \ncorrect_negative=\"thr_correction\", \nthr_negative=0.01 ,\nblank_value = 0.0,\nblank_array = [0.0],\n)\n\nThis function plot all the data from .csv file, note that assume that the first colums is the time\n\nArguments:\n\nlabel_exp::String: The label of the experiment.  \npath_to_data::String: The path to the .csv of data\n\nKey Arguments:\n\npath_to_annotation::Any = missing: The path to the .csv of annotation \npath_to_plot= \"NA\":String, path to save the plots.\nsave_plot=false :Bool, save the plot or not\ndisplay_plots=true:Bool,  Whether or not diplay the plot in julia\noverlay_plots =true :Bool, if true it does one plot overlaying  all dataset curves\nblank_subtraction=\"NO\": String, how perform the blank subtration, options \"NO\",\"avgsubtraction\" (subtration of average value of blanks) and \"timeavg\" (subtration of  time average value of blanks).  \naverage_replicate=false Bool, perform or not the average of replicates. Works only if an annotation path is provided\nblank_value = 0.0: used only if path_to_annotation = missingand blank_subtraction != \"NO \". It is used as average value of the blank\nblank_array = [0.0]:used only if path_to_annotation = missingand blank_subtraction != \"NO \". It is used as array of the blanks values\ncorrect_negative=\"thr_correction\"  ;: String, How to treat negative values after blank subtraction. If \"thr_correction\" it put a thr on the minimum value of the data with blank subracted,   if \"blank_correction\" uses blank distribution to impute negative values, if \"remove\" the values are just removed.\n\nOutput:\n\nFor this function the output are saved or displayed depending on the values of key arguments.\n\n\n\n\n\n","category":"function"},{"location":"api/#Fitting-one-a-.csv-file","page":"API","title":"Fitting one a .csv file","text":"","category":"section"},{"location":"api/#Log-Lin-fitting-2","page":"API","title":"Log-Lin fitting","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"JMAKi.fit_one_file_Log_Lin","category":"page"},{"location":"api/","page":"API","title":"API","text":"JMAKi.fit_one_file_Log_Lin","category":"page"},{"location":"api/#JMAKi.fit_one_file_Log_Lin","page":"API","title":"JMAKi.fit_one_file_Log_Lin","text":"fit_one_file_Log_Lin(\nlabel_exp::String, \npath_to_data::String; \npath_to_annotation::Any = missing,\npath_to_results=\"NA\",\npath_to_plot=\"NA\",\ndisplay_plots=true,\nsave_plots=false, \nwrite_res=false,\ntype_of_smoothing=\"rolling_avg\",\npt_avg=7,\npt_smoothing_derivative=7, \npt_min_size_of_win=7, \ntype_of_win=\"maximum\", \nthreshold_of_exp=0.9,\ndo_blank_subtraction=\"avg_blank\",\navg_replicate=false, \ncorrect_negative=\"thr_correction\", \nthr_negative=0.01, \nmultiple_scattering_correction=false, \nmethod_multiple_scattering_correction=\"interpolation\",\ncalibration_OD_curve=\"NA\",\nthr_lowess=0.05, \nverbose=false,\nblank_value = 0.0,\nblank_array = [0.0],)\n\nThis function fits a logarithmic-linear model to a csv file. The function assumes that the first column is the time, see the documentation for example of the data format. It evaluate the specific growht rate, the with a statistical threshold it individuates a exponetial window and perform a-log lin fitting\n\nArguments:\n\nlabel_exp::String: The label of the experiment.\npath_to_data::String: Path to csv file containing the data    - label_exp::String: The label of the experiment.\n\nKey Arguments:\n\npath_to_annotation::Any = missing: The path to the .csv of annotation .\npath_to_plot= \"NA\":String, path to save the plots.\nwrite_res=false: Bool, write the results in pathtoresults folder.\npath_to_results= \"NA\":String, path to the folder where save the results.\nsave_plot=false :Bool, save the plot or not.\naverage_replicate=false Bool, perform or not the average of replicates. Works only if an annotation path is provided\ndisplay_plots=true:Bool,  Whether or not diplay the plot in julia.\ntype_of_smoothing=\"rolling_avg\": String, How to smooth the data, options: \"NO\" , \"rolling avg\" rolling average of the data, and \"lowess\".\npt_avg=7:Int, The number of points to do rolling average smoothing.\npt_smoothing_derivative=7:Int,  Number of points for evaluation of specific growth rate. If <2 it uses interpolation algorithm otherwise a sliding window approach.\npt_min_size_of_win=7:Int, The minimum size of the exponential windows in the number of smoothed points.\ntype_of_win=\"maximum\":String, How the exponential phase window is selected (\"maximum\" or \"global_thr\").\nthreshold_of_exp=0.9:Float, The threshold of the growth rate in quantile to define the exponential windows, a value between 0 and 1.\nmultiple_scattering_correction=false:Bool, Whether or not correct the data qith a calibration curve.\ncalibration_OD_curve=\"NA\": String, The path where the .csv calibration data are located, used only if multiple_scattering_correction=true.\nmultiple_scattering_correction=false: Bool, if true uses the given calibration curve to correct the data for muliple scattering.\nmethod_multiple_scattering_correction=\"interpolation\": String, How perform the inference of multiple scattering curve, options: \"interpolation\" or   \"exp_fit\" it uses an exponential fit from \"Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications\"\nthr_lowess=0.05: Float64 keyword argument of lowees smoothing.\ncorrect_negative=\"thr_correction\": # if \"thrcorrection\" it put a thr on the minimum value of the data with blank subracted, if \"blankcorrection\" uses blank distrib to impute negative values.\nblank_value = 0.0: used only if path_to_annotation = missingand do_blank_subtraction != \"NO \". It is used as average value of the blank.\nblank_array = [0.0]:used only if path_to_annotation = missingand do_blank_subtraction != \"NO \". It is used as array of the blanks values.\ncorrect_negative=\"thr_correction\"  ;: String, How to treat negative values after blank subtraction. If \"thr_correction\" it put a thr on the minimum value of the data with blank subracted, if \"blank_correction\" uses blank distribution to impute negative values, if \"remove\" the values are just removed.\nthr_negative=0.01: FLoat: used only if correct_negative == \"thr_correction\" the data under this threshold will be changed to this value.\ndo_blank_subtraction=\"NO\": String, how perform the blank subtration, options \"NO\",\"avgsubtraction\" (subtration of average value of blanks) and \"timeavg\" (subtration of  time average value of blanks).  \n\nOutput:\n\na matrix with the following contents in each row : [label_exp, name_well, start of exp win,  end of exp win,  start of exp win, Maximum specific GR ,specific GR,  2 sigma  CI of GR, doubling time,doubling time - 2 sigma ,doubling time + 2 sigma  , intercept log-lin fitting, 2 sigma intercept ,R^2]\nThe plots of the log-linear fitting and of the dynamics of specific growth rate if save_plot=true or display_plots=true\n\n\n\n\n\n","category":"function"},{"location":"api/#ODE-fitting-2","page":"API","title":"ODE fitting","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"JMAKi.fit_file_ODE","category":"page"},{"location":"api/","page":"API","title":"API","text":"JMAKi.fit_file_ODE","category":"page"},{"location":"api/#JMAKi.fit_file_ODE","page":"API","title":"JMAKi.fit_file_ODE","text":"fit_file_ODE(\nlabel_exp::String, \npath_to_data::String, \nmodel::String,\nlb_param::Vector{Float64},\nub_param::Vector{Float64};\npath_to_annotation::Any = missing,\noptmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(), \nintegrator=Tsit5(),\npath_to_results=\"NA\",\npath_to_plot=\"NA\",\nloss_type=\"RE\", \nsmoothing=false,\ntype_of_smoothing=\"lowess\",\ndisplay_plots=true,\nsave_plots=false,\nverbose=false, \nwrite_res=false, \npt_avg=1, \npt_smooth_derivative=7, \ndo_blank_subtraction=\"avg_blank\", \navg_replicate=false,\ncorrect_negative=\"thr_correction\",\nthr_negative=0.01,  \nmultiple_scattering_correction=false, \nmethod_multiple_scattering_correction=\"interpolation\",\ncalibration_OD_curve=\"NA\", \nPopulationSize=300,\nmaxiters=2000000,\nabstol=0.00001,\nthr_lowess=0.05,\nblank_value = 0.0,\nblank_array = [0.0],)\n\nThis function fits a ODE model to a csv file. The function assumes that the first column is the time, see the documentation for example of the data format. It evaluate the specific growht rate, the with a statistical threshold it individuates a exponetial window and perform a-log lin fitting\n\nArguments:\n\ndata::Matrix{Float64}: The dataset with the growth curve, where the first row represents times, and the second row represents the variable to fit (e.g., OD), see documentation.\nlabel_exp::String: The label of the experiment.\nmodel::String:String of the ODE to be fitted. See the documentation for the complete list.\nlb_param::Vector{Float64}: Lower bounds of the model parameters.\nub_param::Vector{Float64}: Upper bounds of the model parameters.\n\nKey Arguments:\n\nparam= lb_param .+ (ub_param.-lb_param)./2:Vector{Float64}, Initial guess for the model parameters.\n`integrator =Tsit5()' sciML integrator. If using piecewise model please use  'KenCarp4(autodiff=true)'.\noptmizator = BBO_adaptive_de_rand_1_bin_radiuslimited() optimizer from optimizationBBO.\ntype_of_loss:=\"RE\": Type of loss function to be used. (options= \"RE\", \"L2\", \"L2derivative\" and \"blankweighted_L2\").\naverage_replicate=false Bool, perform or not the average of replicates. Works only if an annotation path is provided\npath_to_annotation::Any = missing: The path to the .csv of annotation .\npath_to_plot= \"NA\":String, path to save the plots.\nwrite_res=false: Bool, write the results in pathtoresults folder.\npath_to_results= \"NA\":String, path to the folder where save the results.\nsave_plot=false :Bool, save the plot or not.\ndisplay_plots=true:Bool,  Whether or not diplay the plot in julia.\ntype_of_smoothing=\"rolling_avg\": String, How to smooth the data, options: \"NO\" , \"rolling avg\" rolling average of the data, and \"lowess\".\npt_avg=7:Int, The number of points to do rolling average smoothing.\npt_smoothing_derivative=7:Int,  Number of points for evaluation of specific growth rate. If <2 it uses interpolation algorithm otherwise a sliding window approach.\npt_min_size_of_win=7:Int, The minimum size of the exponential windows in the number of smoothed points.\ntype_of_win=\"maximum\":String, How the exponential phase window is selected (\"maximum\" or \"global_thr\").\nthreshold_of_exp=0.9:Float, The threshold of the growth rate in quantile to define the exponential windows, a value between 0 and 1.\nmultiple_scattering_correction=false:Bool, Whether or not correct the data qith a calibration curve.\ncalibration_OD_curve=\"NA\": String, The path where the .csv calibration data are located, used only if multiple_scattering_correction=true.\nmultiple_scattering_correction=false: Bool, if true uses the given calibration curve to correct the data for muliple scattering.\nmethod_multiple_scattering_correction=\"interpolation\": String, How perform the inference of multiple scattering curve, options: \"interpolation\" or   \"exp_fit\" it uses an exponential fit from \"Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications\"\nthr_lowess=0.05: Float64 keyword argument of lowees smoothing.\nPopulationSize =100: Size of the population of the optimization\nmaxiters=2000000: stop criterion, the optimization is stopped when the number of iterations is bigger than maxiters\nabstol = 0.00001: stop criterion, the optimization is stopped when the loss is lesser than abstol\ncorrect_negative=\"thr_correction\": # if \"thrcorrection\" it put a thr on the minimum value of the data with blank subracted, if \"blankcorrection\" uses blank distrib to impute negative values.\nblank_value = 0.0: used only if path_to_annotation = missingand do_blank_subtraction != \"NO \". It is used as average value of the blank.\nblank_array = [0.0]:used only if path_to_annotation = missingand do_blank_subtraction != \"NO \". It is used as array of the blanks values.\ncorrect_negative=\"thr_correction\"  ;: String, How to treat negative values after blank subtraction. If \"thr_correction\" it put a thr on the minimum value of the data with blank subracted, if \"blank_correction\" uses blank distribution to impute negative values, if \"remove\" the values are just removed..\ndo_blank_subtraction=\"NO\": String, how perform the blank subtration, options \"NO\",\"avgsubtraction\" (subtration of average value of blanks) and \"timeavg\" (subtration of  time average value of blanks).  \n\nOutput:\n\nan matrix with the following contents for each row :[] \"name of model\", \"well\", \"param_1\",\"param_2\",..,\"param_n\",\"maximum specific gr using ode\",\"maximum specific gr using data\", \"objective function value (i.e. loss of the solution)\"] where ' \"param1\",\"param2\",..,\"param_n\" ' are the parameter of the selected ODE as in the documentation.\nThe plots of the fit if save_plot=true or display_plots=true.\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"JMAKi.fit_file_custom_ODE","category":"page"},{"location":"api/","page":"API","title":"API","text":"JMAKi.fit_file_custom_ODE","category":"page"},{"location":"api/#JMAKi.fit_file_custom_ODE","page":"API","title":"JMAKi.fit_file_custom_ODE","text":"fit_file_custom_ODE(\nlabel_exp::String, \npath_to_data::String,\nmodel::Any, \nlb_param::Vector{Float64},\nub_param::Vector{Float64},\nn_equation::Int;\npath_to_annotation::Any = missing,\noptmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(), \nintegrator=Tsit5(),\npath_to_results=\"NA\",\npath_to_plot=\"NA\", \nloss_type=\"RE\",\nsmoothing=false,\ntype_of_smoothing=\"lowess\",\ndisplay_plots=true,\nsave_plots=false,\nverbose=false, \nwrite_res=false,\npt_avg=1,\npt_smooth_derivative=7,\ndo_blank_subtraction=\"avg_blank\",\navg_replicate=false,\ncorrect_negative=\"thr_correction\", \nthr_negative=0.01,  \nmultiple_scattering_correction=false, \nmethod_multiple_scattering_correction=\"interpolation\",\ncalibration_OD_curve=\"NA\", \nPopulationSize=300,\nmaxiters=2000000,\nabstol=0.00001,\nthr_lowess=0.05,\nblank_value = 0.0,\nblank_array = [0.0],)\n\nThis function is designed for fitting an ordinary differential equation (ODE) model to a dataset in a csv file. . It utilizes a customizable ODE model, see documentation on how declare the model\n\nArguments:\n\nlabel_exp::String: The label of the experiment.\npath_to_data::String: Path to csv file containing the data\nmodel::Any: Function of the ODE to be fitted. See the documentation for examples.\nlb_param::Vector{Float64}: Lower bounds of the model parameters.\nub_param::Vector{Float64}: Upper bounds of the model parameters.\nn_equation::Int:  number ode in the system\n\nKey Arguments:\n\nparam= lb_param .+ (ub_param.-lb_param)./2:Vector{Float64}, Initial guess for the model parameters.\n`integrator =Tsit5()' sciML integrator. If using piecewise model please use  'KenCarp4(autodiff=true)'.\noptmizator = BBO_adaptive_de_rand_1_bin_radiuslimited() optimizer from optimizationBBO.\ntype_of_loss:=\"RE\": Type of loss function to be used. (options= \"RE\", \"L2\", \"L2derivative\" and \"blankweighted_L2\").\naverage_replicate=false Bool, perform or not the average of replicates. Works only if an annotation path is provided\npath_to_annotation::Any = missing: The path to the .csv of annotation .\npath_to_plot= \"NA\":String, path to save the plots.\nwrite_res=false: Bool, write the results in pathtoresults folder.\npath_to_results= \"NA\":String, path to the folder where save the results.\nsave_plot=false :Bool, save the plot or not.\ndisplay_plots=true:Bool,  Whether or not diplay the plot in julia.\ntype_of_smoothing=\"rolling_avg\": String, How to smooth the data, options: \"NO\" , \"rolling avg\" rolling average of the data, and \"lowess\".\npt_avg=7:Int, The number of points to do rolling average smoothing.\npt_smoothing_derivative=7:Int,  Number of points for evaluation of specific growth rate. If <2 it uses interpolation algorithm otherwise a sliding window approach.\npt_min_size_of_win=7:Int, The minimum size of the exponential windows in the number of smoothed points.\ntype_of_win=\"maximum\":String, How the exponential phase window is selected (\"maximum\" or \"global_thr\").\nthreshold_of_exp=0.9:Float, The threshold of the growth rate in quantile to define the exponential windows, a value between 0 and 1.\nmultiple_scattering_correction=false:Bool, Whether or not correct the data qith a calibration curve.\ncalibration_OD_curve=\"NA\": String, The path where the .csv calibration data are located, used only if multiple_scattering_correction=true.\nmultiple_scattering_correction=false: Bool, if true uses the given calibration curve to correct the data for muliple scattering.\nmethod_multiple_scattering_correction=\"interpolation\": String, How perform the inference of multiple scattering curve, options: \"interpolation\" or   \"exp_fit\" it uses an exponential fit from \"Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications\"\nthr_lowess=0.05: Float64 keyword argument of lowees smoothing.\nPopulationSize =100: Size of the population of the optimization\nmaxiters=2000000: stop criterion, the optimization is stopped when the number of iterations is bigger than maxiters\nabstol = 0.00001: stop criterion, the optimization is stopped when the loss is lesser than abstol\ncorrect_negative=\"thr_correction\": # if \"thrcorrection\" it put a thr on the minimum value of the data with blank subracted, if \"blankcorrection\" uses blank distrib to impute negative values.\nblank_value = 0.0: used only if path_to_annotation = missingand blank_subtraction != \"NO \". It is used as average value of the blank.\nblank_array = [0.0]:used only if path_to_annotation = missingand blank_subtraction != \"NO \". It is used as array of the blanks values.\ncorrect_negative=\"thr_correction\"  ;: String, How to treat negative values after blank subtraction. If \"thr_correction\" it put a thr on the minimum value of the data with blank subracted, if \"blank_correction\" uses blank distribution to impute negative values, if \"remove\" the values are just removed..\ndo_blank_subtraction=\"NO\": String, how perform the blank subtration, options \"NO\",\"avgsubtraction\" (subtration of average value of blanks) and \"timeavg\" (subtration of  time average value of blanks).  \n\nOutput:\n\na matrix with the following contents for each row : [ \"name of model\", \"well\", \"param_1\",\"param_2\",..,\"param_n\",\"maximum specific gr using ode\",\"maximum specific gr using data\", \"objective function value (i.e. loss of the solution)\"] where ' \"param1\",\"param2\",..,\"param_n\" ' .\nThe plots of the fit if save_plot=true or display_plots=true\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"JMAKi.ODE_model_selection_file","category":"page"},{"location":"api/","page":"API","title":"API","text":"JMAKi.ODE_model_selection_file","category":"page"},{"location":"api/#JMAKi.ODE_model_selection_file","page":"API","title":"JMAKi.ODE_model_selection_file","text":"ODE_model_selection_file(\nlabel_exp::String, \npath_to_data::String, \nmodels_list::Vector{String}, \nlb_param_array::Any, \nub_param_array::Any; \npath_to_annotation::Any = missing,\noptmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(), \nintegrator=Tsit5(), \npath_to_results=\"NA\",\npath_to_plot=\"NA\", \nloss_type=\"L2\", \nsmoothing=false,\ntype_of_smoothing=\"lowess\",\ndisplay_plot_best_model=false, \nsave_plot_best_model=false,\nbeta_penality=2.0, \nverbose=false,\nwrite_res=false,\npt_avg=1,\npt_smooth_derivative=7, \ndo_blank_subtraction=\"avg_blank\", \navg_replicate=false,\ncorrect_negative=\"thr_correction\", \nthr_negative=0.01,  \nmultiple_scattering_correction=false,\nmethod_multiple_scattering_correction=\"interpolation\",\ncalibration_OD_curve=\"NA\",  \nPopulationSize=300,\nmaxiters=2000000,\nabstol=0.00001,\nthr_lowess=0.05,\ncorrection_AIC=true,\nblank_value = 0.0,\nblank_array = [0.0],)\n\nThis function performs model selection  of ODE for a full csv file.\n\nArguments:\n\nlabel_exp::String: The label of the experiment.\npath_to_data::String: Path to csv file containing the data    \nmodels_list::Vector{String}: list of ODE model used\nmodels_list::Vector{String}: A vector of ODE models to evaluate.\nlb_param_array::Any: Lower bounds for the parameters (compatible with the models).\nub_param_array::Any: Upper bounds\n\nKey Arguments:\n\nparam= lb_param .+ (ub_param.-lb_param)./2:Vector{Float64}, Initial guess for the model parameters.\n`integrator =Tsit5()' sciML integrator. If using piecewise model please use  'KenCarp4(autodiff=true)'.\noptmizator = BBO_adaptive_de_rand_1_bin_radiuslimited() optimizer from optimizationBBO.\ntype_of_loss:=\"RE\": Type of loss function to be used. (options= \"RE\", \"L2\", \"L2derivative\" and \"blankweighted_L2\").\naverage_replicate=false Bool, perform or not the average of replicates. Works only if an annotation path is provided\npath_to_annotation::Any = missing: The path to the .csv of annotation .\npath_to_plot= \"NA\":String, path to save the plots.\nwrite_res=false: Bool, write the results in pathtoresults folder.\npath_to_results= \"NA\":String, path to the folder where save the results.\nsave_plot=false :Bool, save the plot or not.\ndisplay_plots=true:Bool,  Whether or not diplay the plot in julia.\ntype_of_smoothing=\"rolling_avg\": String, How to smooth the data, options: \"NO\" , \"rolling avg\" rolling average of the data, and \"lowess\".\npt_avg=7:Int, The number of points to do rolling average smoothing.\npt_smoothing_derivative=7:Int,  Number of points for evaluation of specific growth rate. If <2 it uses interpolation algorithm otherwise a sliding window approach.\npt_min_size_of_win=7:Int, The minimum size of the exponential windows in the number of smoothed points.\ntype_of_win=\"maximum\":String, How the exponential phase window is selected (\"maximum\" or \"global_thr\").\nthreshold_of_exp=0.9:Float, The threshold of the growth rate in quantile to define the exponential windows, a value between 0 and 1.\nmultiple_scattering_correction=false:Bool, Whether or not correct the data qith a calibration curve.\ncalibration_OD_curve=\"NA\": String, The path where the .csv calibration data are located, used only if multiple_scattering_correction=true.\nmultiple_scattering_correction=false: Bool, if true uses the given calibration curve to correct the data for muliple scattering.\nmethod_multiple_scattering_correction=\"interpolation\": String, How perform the inference of multiple scattering curve, options: \"interpolation\" or   \"exp_fit\" it uses an exponential fit from \"Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications\"\nthr_lowess=0.05: Float64 keyword argument of lowees smoothing.\nPopulationSize =100: Size of the population of the optimization\nmaxiters=2000000: stop criterion, the optimization is stopped when the number of iterations is bigger than maxiters\nabstol = 0.00001: stop criterion, the optimization is stopped when the loss is lesser than abstol\ncorrect_negative=\"thr_correction\": # if \"thrcorrection\" it put a thr on the minimum value of the data with blank subracted, if \"blankcorrection\" uses blank distrib to impute negative values.\nblank_value = 0.0: used only if path_to_annotation = missingand blank_subtraction != \"NO \". It is used as average value of the blank.\nblank_array = [0.0]:used only if path_to_annotation = missingand blank_subtraction != \"NO \". It is used as array of the blanks values.\ncorrect_negative=\"thr_correction\"  ;: String, How to treat negative values after blank subtraction. If \"thr_correction\" it put a thr on the minimum value of the data with blank subracted, if \"blank_correction\" uses blank distribution to impute negative values, if \"remove\" the values are just removed..\ndo_blank_subtraction=\"NO\": String, how perform the blank subtration, options \"NO\",\"avgsubtraction\" (subtration of average value of blanks) and \"timeavg\" (subtration of  time average value of blanks).  \ncorrection_AIC=true: Bool, do finite samples correction of AIC.\nbeta_penality=2.0 penality  parameters for AIC (or AICc) evaluation.\n\nOutput:\n\nan matrix with the following contents for each row : [ \"name of model\", \"well\", \"param_1\",\"param_2\",..,\"param_n\",\"maximum specific gr using ode\",\"maximum specific gr using data\", \"objective function value (i.e. loss of the solution)\"] where ' \"param1\",\"param2\",..,\"param_n\" ' .\nThe plots of the fit if save_plot=true or display_plots=true\n\n\n\n\n\n","category":"function"},{"location":"api/#NL-fitting","page":"API","title":"NL fitting","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"JMAKi.fit_NL_model_file","category":"page"},{"location":"api/","page":"API","title":"API","text":"JMAKi.fit_NL_model_file","category":"page"},{"location":"api/#JMAKi.fit_NL_model_file","page":"API","title":"JMAKi.fit_NL_model_file","text":"fit_NL_model_file(\nlabel_exp::String,\npath_to_data::String, \nmodel::Any,\nlb_param::Vector{Float64},\nub_param::Vector{Float64};\npath_to_annotation::Any = missing,\nu0=lb_param .+ (ub_param .- lb_param) ./ 2,\nmethod_of_fitting=\"MCMC\",\nnrep=100,\nerrors_estimation=false,\noptmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(), \npath_to_results=\"NA\", \npath_to_plot=\"NA\", \nloss_type=\"RE\", \nsmoothing=false,\ntype_of_smoothing=\"lowess\",\ndisplay_plots=true,\nsave_plots=false,\nverbose=false, \nwrite_res=false, \npt_avg=1, \npt_smooth_derivative=7, \ndo_blank_subtraction=\"avg_blank\", \navg_replicate=false, \ncorrect_negative=\"thr_correction\",\nthr_negative=0.01,  \nmultiple_scattering_correction=false, \nmethod_multiple_scattering_correction=\"interpolation\",\ncalibration_OD_curve=\"NA\",\nPopulationSize=300,\nmaxiters=2000000,\nabstol=0.00001,\nthr_lowess=0.05,\npenality_CI=8.0,\nsize_bootstrap=0.7,\nblank_value = 0.0,\nblank_array = [0.0],\n)\n\nThis function performs NL model selection of one NL model for a full csv file\n\nArguments\n\nlabel_exp::String,  label of the experiment.\npath_to_data::String. path to the csv data frame. See documentation for formatting it.\nmodel::Any:  functions or strings (for harcoded NL model) of the NL models\nlb_param::Any:Array of Lower bounds for the parameters (compatible with the models).\nub_param::Any:Array of Upper bounds for the parameters (compatible with the models).\n\nKey Arguments:\n\nmethod_of_fitting=\"MCMC\": String, how perform the NL fit. Options \"MCMC\",\"Bootstrap\",\"Normal\", and \"Morris_sensitivity\"\nnrep=100. Number of MCMC steps.\nparam= lb_param .+ (ub_param.-lb_param)./2:Vector{Float64}, Initial guess for the model parameters.\noptmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited() optimizer from optimizationBBO.\nsave_plots=false :Bool, save the plot or not.\ndisplay_plots=true:Bool,  Whether or not diplay the plot in julia.\ntype_of_smoothing=\"rolling_avg\": String, How to smooth the data, options: \"NO\" , \"rolling avg\" rolling average of the data, and \"lowess\".\npt_avg=7: Number of points to generate the initial condition or do the rolling avg smoothing.\nsmoothing=false: Whether to apply smoothing to the data or not.\ntype_of_loss:=\"RE\": Type of loss function to be used. (options= \"RE\", \"L2\", \"L2derivative\" and \"blankweighted_L2\").\npt_smoothing_derivative=7:Int,  Number of points for evaluation of specific growth rate. If <2 it uses interpolation algorithm otherwise a sliding window approach.\ncalibration_OD_curve=\"NA\": String, The path where the .csv calibration data are located, used only if multiple_scattering_correction=true.\nmultiple_scattering_correction=false: Bool, if true uses the given calibration curve to correct the data for muliple scattering.\nmethod_multiple_scattering_correction=\"interpolation\": String, How perform the inference of multiple scattering curve, options: \"interpolation\" or   \"exp_fit\" it uses an exponential fit from \"Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications\"\nthr_lowess=0.05: Float64, keyword argument of lowess smoothing\nblank_value = 0.0: used only if path_to_annotation = missingand blank_subtraction != \"NO \". It is used as average value of the blank.\nblank_array = [0.0]:used only if path_to_annotation = missingand blank_subtraction != \"NO \". It is used as array of the blanks values.\ncorrect_negative=\"thr_correction\"  ;: String, How to treat negative values after blank subtraction. If \"thr_correction\" it put a thr on the minimum value of the data with blank subracted, if \"blank_correction\" uses blank distribution to impute negative values, if \"remove\" the values are just removed..\ndo_blank_subtraction=\"NO\": String, how perform the blank subtration, options \"NO\",\"avgsubtraction\" (subtration of average value of blanks) and \"timeavg\" (subtration of  time average value of blanks).  \nPopulationSize =100: Size of the population of the optimization\nmaxiters=2000000: stop criterion, the optimization is stopped when the number of iterations is bigger than maxiters\nabstol = 0.00001: stop criterion, the optimization is stopped when the loss is lesser than abstol\npenality_CI=2.0, used only in segementation to force the optimization to respect continuty on bonduar\ncorrection_AIC=true: Bool, do finite samples correction of AIC.\nbeta_param=2.0 penality  parameters for AIC (or AICc) evaluation.\nsize_bootstrap=0.7: Float, the fraction of data used each Bootstrap run. Used only if method is \"Bootstrap\"\nwrite_res=false: Bool, write the results in pathtoresults folder.\npath_to_results= \"NA\":String, path to the folder where save the results.\ncorrect_negative=\"thr_correction\": # if \"thrcorrection\" it put a thr on the minimum value of the data with blank subracted, if \"blankcorrection\" uses blank distrib to impute negative values.\n\nOutput (if results_NL_fit =fit_NL_model_file(...):\n\na matrix with the following contents for each row : [ \"label of exp\", \"well\", \"param_1\",\"param_2\",..,\"param_n\",\"maximum specific gr using model\",\"maximum specific gr using data\", \"objective function value (i.e. loss of the solution)\"] where ' \"param1\",\"param2\",..,\"param_n\" ' .\nThe plots of the fit if save_plot=true or display_plots=true\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"JMAKi.fit_NL_model_selection_file","category":"page"},{"location":"api/","page":"API","title":"API","text":"JMAKi.fit_NL_model_selection_file","category":"page"},{"location":"api/#JMAKi.fit_NL_model_selection_file","page":"API","title":"JMAKi.fit_NL_model_selection_file","text":"function fit_NL_model_selection_file(\nlabel_exp::String, \npath_to_data::String, \nlist_model_function::Any,\nlist_lb_param::Vector{Float64}, \nlist_ub_param::Vector{Float64}; \npath_to_annotation::Any = missing,\nmethod_of_fitting=\"MCMC\",\nnrep=100,\nlist_u0=lb_param .+ (ub_param .- lb_param) ./ 2,\noptmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(), \npath_to_results=\"NA\", \npath_to_plot=\"NA\", \nloss_type=\"RE\",\nsmoothing=false, \ntype_of_smoothing=\"lowess\",\ndisplay_plots=true,\nsave_plots=false,\nverbose=false, \nwrite_res=false,\npt_avg=1,\npt_smooth_derivative=7, \ndo_blank_subtraction=\"avg_blank\", \navg_replicate=false, \ncorrect_negative=\"thr_correction\", \nthr_negative=0.01,  \nmultiple_scattering_correction=false, \nmethod_multiple_scattering_correction=\"interpolation\",\ncalibration_OD_curve=\"NA\", \nPopulationSize=300,\nmaxiters=2000000,\nabstol=0.00001,\nthr_lowess=0.05,\nbeta_param=2.0,\npenality_CI=8.0,\nsize_bootstrap=0.7,\ncorrection_AIC=true,\nblank_value = 0.0,\nblank_array = [0.0],\n)\n\nThis function performs NL model selection of an array of NL models, it uses AIC or AICc depending on user inputs. This is done for a full .csv file.\n\nArguments\n\nlabel_exp::String,  label of the experiment.\npath_to_data::String. path to the csv data frame. See documentation for formatting it.\nlist_model_function::Any: Array containing functions or strings of the NL models\nlist_lb_param::Any:Array of Lower bounds for the parameters (compatible with the models).\nlist_ub_param::Any:Array of Upper bounds for the parameters (compatible with the models).\n\nKey Arguments:\n\nmethod_of_fitting=\"MCMC\": String, how perform the NL fit. Options \"MCMC\",\"Bootstrap\",\"Normal\", and \"Morris_sensitivity\"\nnrep=100. Number of MCMC steps.\nparam= lb_param .+ (ub_param.-lb_param)./2:Vector{Float64}, Initial guess for the model parameters.\noptmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited() optimizer from optimizationBBO.\nsave_plot_best_model=false :Bool, save the plot or not.\npath_to_plot= \"NA\":String, path to save the plots.\ndisplay_plots=true:Bool,  Whether or not diplay the plot in julia.\ntype_of_smoothing=\"rolling_avg\": String, How to smooth the data, options: \"NO\" , \"rolling avg\" rolling average of the data, and \"lowess\".\npt_avg=7: Number of points to generate the initial condition or do the rolling avg smoothing.\nsmoothing=false: Whether to apply smoothing to the data or not.\ntype_of_loss:=\"RE\": Type of loss function to be used. (options= \"RE\", \"L2\", \"L2derivative\" and \"blankweighted_L2\").\npt_smoothing_derivative=7:Int,  Number of points for evaluation of specific growth rate. If <2 it uses interpolation algorithm otherwise a sliding window approach.\ncalibration_OD_curve=\"NA\": String, The path where the .csv calibration data are located, used only if multiple_scattering_correction=true.\nmultiple_scattering_correction=false: Bool, if true uses the given calibration curve to correct the data for muliple scattering.\nmethod_multiple_scattering_correction=\"interpolation\": String, How perform the inference of multiple scattering curve, options: \"interpolation\" or   \"exp_fit\" it uses an exponential fit from \"Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications\"\nthr_lowess=0.05: Float64 keyword argument of lowess smoothing\nPopulationSize =100: Size of the population of the optimization\nmaxiters=2000000: stop criterion, the optimization is stopped when the number of iterations is bigger than maxiters\nabstol = 0.00001: stop criterion, the optimization is stopped when the loss is lesser than abstol\npenality_CI=8.0, used only in segementation to force the optimization to respect continuty on bonduar\ncorrection_AIC=true: Bool, do finite samples correction of AIC.\nbeta_param=2.0 penality  parameters for AIC (or AICc) evaluation.\nsize_bootstrap=0.7: Float, the fraction of data used each Bootstrap run. Used only if method is \"Bootstrap\"\nwrite_res=false: Bool, write the results in pathtoresults folder.\nblank_value = 0.0: used only if path_to_annotation = missingand blank_subtraction != \"NO \". It is used as average value of the blank.\nblank_array = [0.0]:used only if path_to_annotation = missingand blank_subtraction != \"NO \". It is used as array of the blanks values.\ncorrect_negative=\"thr_correction\": String, How to treat negative values after blank subtraction. If \"thr_correction\" it put a thr on the minimum value of the data with blank subracted, if \"blank_correction\" uses blank distribution to impute negative values, if \"remove\" the values are just removed..\ndo_blank_subtraction=\"NO\": String, how perform the blank subtration, options \"NO\",\"avgsubtraction\" (subtration of average value of blanks) and \"timeavg\" (subtration of  time average value of blanks).  \npath_to_results= \"NA\":String, path to the folder where save the results.\n\nOutput (if results_NL_fit =NL_model_selection(...):\n\na matrix with the following contents for each row : [ \"label of exp\", \"well\", \"param_1\",\"param_2\",..,\"param_n\",\"maximum specific gr using model\",\"maximum specific gr using data\", \"objective function value (i.e. loss of the solution)\"] where ' \"param1\",\"param2\",..,\"param_n\" ' .\nThe plots of the fit if save_plot=true or display_plots=true\n\n\n\n\n\n","category":"function"},{"location":"api/#Segmented-fitting-2","page":"API","title":"Segmented fitting","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"JMAKi.segmentation_ODE_file","category":"page"},{"location":"api/","page":"API","title":"API","text":"JMAKi.fit_NL_segmentation_file","category":"page"},{"location":"api/#JMAKi.fit_NL_segmentation_file","page":"API","title":"JMAKi.fit_NL_segmentation_file","text":"fit_NL_segmentation_file(\nlabel_exp::String, \npath_to_data::String, \nlist_model_function::Any,\nlist_lb_param::Vector{Vector{Float64}}, \nlist_ub_param::Vector{Vector{Float64}}, \nn_change_points::Int;\npath_to_annotation::Any = missing,\nmethod_of_fitting=\"MCMC\",\nnrep=100,\nlist_u0=lb_param .+ (ub_param .- lb_param) ./ 2,\noptmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(), \npath_to_results=\"NA\",\npath_to_plot=\"NA\", \nloss_type=\"RE\", \nsmoothing=false, \ntype_of_smoothing=\"lowess\",\ndisplay_plots=true,\nsave_plots=false,\nverbose=false, \nwrite_res=false,\npt_avg=1, \npt_smooth_derivative=7, \ndo_blank_subtraction=\"avg_blank\", \navg_replicate=false,\ncorrect_negative=\"thr_correction\", \nthr_negative=0.01,  \nmultiple_scattering_correction=false, \nmethod_multiple_scattering_correction=\"interpolation\",\ncalibration_OD_curve=\"NA\",  \nPopulationSize=300,\nmaxiters=2000000,\nabstol=0.00001,\nsize_bootstrap=0.7,\nthr_lowess=0.05,\ndetect_number_cpd=true,\ntype_of_detection=\"sliding_win\",\ntype_of_curve=\"original\",\nfixed_cpd=false,\npenality_CI=8.0,\nbeta_smoothing_ms=2.0,\nwin_size=7,\nn_bins=40,\ncorrection_AIC=true,\nblank_value = 0.0,\nblank_array = [0.0],\n)\n\nThis function performs NL model selection  on a segmented time series, it uses AIC or AICc depending on user inputs. This fuction works on an entire csv file.\n\nArguments\n\nlabel_exp::String,  label of the experiment./\npath_to_data::String. path to the csv data frame. See documentation for formatting it.\nlist_model_function::Any: Array containing functions or strings of the NL models\nlist_lb_param::Any:Array of Lower bounds for the parameters (compatible with the models).\nlist_ub_param::Any:Array of Upper bounds for the parameters (compatible with the models).\nn_max_change_points::Int: Number of change point used, the results will have different number of cp depending on the values of key argument 'typeofdetection' and 'fixed_cpd'\n\nKey Arguments:\n\nmethod_of_fitting=\"MCMC\": String, how perform the NL fit. Options \"MCMC\",\"Bootstrap\",\"Normal\", and \"Morris_sensitivity\"\nnrep=100. Number of MCMC steps.\nparam= lb_param .+ (ub_param.-lb_param)./2:Vector{Float64}, Initial guess for the model parameters.\noptmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited() optimizer from optimizationBBO.\nsave_plots=false :Bool, save the plot or not.\npath_to_plot= \"NA\":String, path to save the plots.\ndisplay_plots=true:Bool,  Whether or not diplay the plot in julia.\ntype_of_smoothing=\"rolling_avg\": String, How to smooth the data, options: \"NO\" , \"rolling avg\" rolling average of the data, and \"lowess\".\npt_avg=7: Number of points to generate the initial condition or do the rolling avg smoothing.\nsmoothing=false: Whether to apply smoothing to the data or not.\ntype_of_loss:=\"RE\": Type of loss function to be used. (options= \"RE\", \"L2\", \"L2derivative\" and \"blankweighted_L2\").\npt_smoothing_derivative=7:Int,  Number of points for evaluation of specific growth rate. If <2 it uses interpolation algorithm otherwise a sliding window approach.\ncalibration_OD_curve=\"NA\": String, The path where the .csv calibration data are located, used only if multiple_scattering_correction=true.\nmultiple_scattering_correction=false: Bool, if true uses the given calibration curve to correct the data for muliple scattering.\nmethod_multiple_scattering_correction=\"interpolation\": String, How perform the inference of multiple scattering curve, options: \"interpolation\" or   \"exp_fit\" it uses an exponential fit from \"Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications\"\nthr_lowess=0.05: Float64 keyword argument of lowess smoothing\nPopulationSize =100: Size of the population of the optimization\nmaxiters=2000000: stop criterion, the optimization is stopped when the number of iterations is bigger than maxiters\nabstol = 0.00001: stop criterion, the optimization is stopped when the loss is lesser than abstol\npenality_CI=2.0, used only in segementation to force the optimization to respect continuty on bonduar\ncorrection_AIC=true: Bool, do finite samples correction of AIC.\nbeta_param=2.0 penality  parameters for AIC (or AICc) evaluation.\nsize_bootstrap=0.7: Float, the fraction of data used each Bootstrap run. Used only if method is \"Bootstrap\"\nwrite_res=false: Bool, write the results in pathtoresults folder.\npath_to_results= \"NA\":String, path to the folder where save the results.\n'typeofdetection=\"slindingwin\"': String, algorithm of cpd to use. Options '\"slindingwin\"' use a slinding window approach, '\"lsdd\"' uses least square density difference (LSDD) from ChangePointDetection.jl \n'typeofcurve=\"original\"': String, on which curve is performed the change point detection algorithm. If '\"original\"' it use the original time series. With '\"deriv\"' it use the specific growth rate time series to perform the cdp.\nmethod_peaks_detection=\"peaks_prominence\": How the peak detection is performed on the dissimilarity curve.  \"peaks_prominence\" orders the peaks by prominence. thr_scan uses a threshold to choose the peaks\nn_bins=40: Int, used if method_peaks_detection=\"thr_scan\" number of bins used to generate the threshold that has nchangepoints peaks\n'detectnumbercpd=true': Bool, if equal to true all the possible combination of lenght 1,2,...,nchangepoints are tested and the best for AICc is returned.\n'fixedcpd=false': Bool If  true it returns the fitting using top nchange_points.\ncorrect_negative=\"thr_correction\": # if \"thrcorrection\" it put a thr on the minimum value of the data with blank subracted, if \"blankcorrection\" uses blank distrib to impute negative values.\n'win_size=14': Int, size of the windows used by the cdp algorithms\n\nOutput (if results_NL_fit =fit_NL_segmentation_file(...):\n\nan matrix with the following contents for each row : [ \"name of model\", \"well\", \"param_1\",\"param_2\",..,\"param_n\",\"maximum specific gr using model\",\"maximum specific gr using data\", \"objective function value (i.e. loss of the solution)\" \"segment number\"] where ' \"param1\",\"param2\",..,\"param_n\" ' .\nThe plots of the fit if save_plot=true or display_plots=true\n\n\n\n\n\n","category":"function"},{"location":"api/","page":"API","title":"API","text":"JMAKi.fit_NL_segmentation_file","category":"page"},{"location":"api/","page":"API","title":"API","text":"JMAKi.segmentation_ODE_file","category":"page"},{"location":"api/#JMAKi.segmentation_ODE_file","page":"API","title":"JMAKi.segmentation_ODE_file","text":"segmentation_ODE_file(\nlabel_exp::String, \npath_to_data::String, \nlist_of_models::Vector{String},  \nlb_param_array::Any, \nub_param_array::Any,\nn_max_change_points::Int;\npath_to_annotation::Any = missing,\ndetect_number_cpd=true,\nfixed_cpd=false,\noptmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(), \nintegrator=Tsit5(), \ntype_of_loss=\"L2\", \ntype_of_detection=\"sliding_win\",\ntype_of_curve=\"original\",\ndo_blank_subtraction=\"avg_blank\",\ncorrect_negative=\"thr_correction\",\nthr_negative=0.01,\npt_avg=1,\nsmoothing=true, \nsave_plots=false, \ndisplay_plots=false, \npath_to_plot=\"NA\",\npath_to_results=\"NA\",\nwin_size=7,\npt_smooth_derivative=0,\npenality_parameter=2.0,\navg_replicate=false,\nmultiple_scattering_correction=\"false\",\nmethod_multiple_scattering_correction=\"interpolation\",\ncalibration_OD_curve=\"NA\",  \nwrite_res=false,\nsave_all_model=false,\nmethod_peaks_detection=\"peaks_prominence\",\nn_bins=40,\nPopulationSize=300,\nmaxiters=2000000,\nabstol=0.00001,\ntype_of_smoothing=\"lowess\",\nthr_lowess=0.05,\nverbose=false,\ncorrection_AIC=true,\nblank_value = 0.0,\nblank_array = [0.0],)\n\nThis function performs model selection for ordinary differential equation (ODE) models while segmenting the time series in various part using change points detection algorithm, for a full csv file.\n\nArguments:\n\nlabel_exp::String: The label of the experiment.\npath_to_data::String: Path to csv file containing the data\nlist_of_models::Vector{String}: A vector of ODE models to evaluate.\nlist_lb_param::Any: Lower bounds for the parameters (compatible with the models).\nlist_ub_param::Any: Upper bounds for the parameters (compatible with the models).\nn_max_change_points::Int: Number of change point used, the results will have different number of cp depending on the values of key argument 'typeofdetection' and 'fixed_cpd'\n\nKey Arguments:\n\nparam= lb_param .+ (ub_param.-lb_param)./2:Vector{Float64}, Initial guess for the model parameters.\n`integrator =Tsit5()' sciML integrator. If using piecewise model please use  'KenCarp4(autodiff=true)'.\noptmizator = BBO_adaptive_de_rand_1_bin_radiuslimited() optimizer from optimizationBBO.\ntype_of_loss:=\"RE\": Type of loss function to be used. (options= \"RE\", \"L2\", \"L2derivative\" and \"blankweighted_L2\").\naverage_replicate=false Bool, perform or not the average of replicates. Works only if an annotation path is provided\npath_to_annotation::Any = missing: The path to the .csv of annotation .\npath_to_plot= \"NA\":String, path to save the plots.\nwrite_res=false: Bool, write the results in pathtoresults folder.\npath_to_results= \"NA\":String, path to the folder where save the results.\nsave_plot=false :Bool, save the plot or not.\ndisplay_plots=true:Bool,  Whether or not diplay the plot in julia.\ntype_of_smoothing=\"rolling_avg\": String, How to smooth the data, options: \"NO\" , \"rolling avg\" rolling average of the data, and \"lowess\".\npt_avg=7:Int, The number of points to do rolling average smoothing.\npt_smoothing_derivative=7:Int,  Number of points for evaluation of specific growth rate. If <2 it uses interpolation algorithm otherwise a sliding window approach.\npt_min_size_of_win=7:Int, The minimum size of the exponential windows in the number of smoothed points.\ntype_of_win=\"maximum\":String, How the exponential phase window is selected (\"maximum\" or \"global_thr\").\nthreshold_of_exp=0.9:Float, The threshold of the growth rate in quantile to define the exponential windows, a value between 0 and 1.\nmultiple_scattering_correction=false:Bool, Whether or not correct the data qith a calibration curve.\ncalibration_OD_curve=\"NA\": String, The path where the .csv calibration data are located, used only if multiple_scattering_correction=true.\nmultiple_scattering_correction=false: Bool, if true uses the given calibration curve to correct the data for muliple scattering.\nmethod_multiple_scattering_correction=\"interpolation\": String, How perform the inference of multiple scattering curve, options: \"interpolation\" or   \"exp_fit\" it uses an exponential fit from \"Direct optical density determination of bacterial cultures in microplates for high-throughput screening applications\"\nthr_lowess=0.05: Float64 keyword argument of lowees smoothing.\nPopulationSize =100: Size of the population of the optimization\nmaxiters=2000000: stop criterion, the optimization is stopped when the number of iterations is bigger than maxiters\nabstol = 0.00001: stop criterion, the optimization is stopped when the loss is lesser than abstol\ncorrect_negative=\"thr_correction\": # if \"thrcorrection\" it put a thr on the minimum value of the data with blank subracted, if \"blankcorrection\" uses blank distrib to impute negative values.\nblank_value = 0.0: used only if path_to_annotation = missingand blank_subtraction != \"NO \". It is used as average value of the blank.\nblank_array = [0.0]:used only if path_to_annotation = missingand blank_subtraction != \"NO \". It is used as array of the blanks values.\ncorrect_negative=\"thr_correction\"  ;: String, How to treat negative values after blank subtraction. If \"thr_correction\" it put a thr on the minimum value of the data with blank subracted, if \"blank_correction\" uses blank distribution to impute negative values, if \"remove\" the values are just removed..\ndo_blank_subtraction=\"NO\": String, how perform the blank subtration, options \"NO\",\"avgsubtraction\" (subtration of average value of blanks) and \"timeavg\" (subtration of  time average value of blanks).  \ncorrection_AIC=true: Bool, do finite samples correction of AIC.\nbeta_penality=2.0 penality  parameters for AIC (or AICc) evaluation.\n'typeofdetection=\"slindingwin\"': String, algorithm of cpd to use. Options '\"slindingwin\"' use a slinding window approach, '\"lsdd\"' uses least square density difference (LSDD) from ChangePointDetection.jl \n'typeofcurve=\"original\"': String, on which curve is performed the change point detection algorithm. If '\"original\"' it use the original time series. With '\"deriv\"' it use the specific growth rate time series to perform the cdp.\nmethod_peaks_detection=\"peaks_prominence\": How the peak detection is performed on the dissimilarity curve.  \"peaks_prominence\" orders the peaks by prominence. thr_scan uses a threshold to choose the peaks\nn_bins=40: Int, used if method_peaks_detection=\"thr_scan\" number of bins used to generate the threshold that has nchangepoints peaks\n'detectnumbercpd=true': Bool, if equal to true all the possible combination of lenght 1,2,...,nchangepoints are tested and the best for AICc is returned.\n'fixedcpd=false': Bool If  true it returns the fitting using top nchange_points.\n'win_size=14': Int, size of the windows used by the cdo algorithms\n'pathtoresults=\"NA\"':String, where to save the results.\n'saveallmodel=false': Bool, if true all the tested model are saved.\ncorrection_AIC=true: Bool, do finite samples correction of AIC.\nbeta_penality=2.0 penality  parameters for AIC (or AICc) evaluation.\n\nOutput:\n\nan matrix with the following contents for each row : [ \"name of model\", \"well\", \"param_1\",\"param_2\",..,\"param_n\",\"maximum specific gr using ode\",\"maximum specific gr using data\", \"objective function value (i.e. loss of the solution)\" \"segment number\"] where ' \"param1\",\"param2\",..,\"param_n\" ' .\nThe plots of the fit if save_plot=true or display_plots=true\n\n\n\n\n\n","category":"function"},{"location":"api/#Simulations","page":"API","title":"Simulations","text":"","category":"section"},{"location":"api/#ODE-simulations","page":"API","title":"ODE simulations","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"JMAKi.ODE_sim","category":"page"},{"location":"api/","page":"API","title":"API","text":"JMAKi.ODE_sim","category":"page"},{"location":"api/#JMAKi.ODE_sim","page":"API","title":"JMAKi.ODE_sim","text":"ODE_sim(\nmodel::String, \nn_start::Vector{Float64}, \ntstart::Float64, \ntmax::Float64,\ndelta_t::Float64, \nparam_of_ode::Vector{Float64};\nintegrator=KenCarp4(),\n)\n\nThis function performs an ODE simulation of a model\n\nArguments:\n\nmodel::String: The model to simulate. For the possible options please check the documentation.\nn_start::Vector{Float64}: The starting conditions.\ntstart::Float64: The start time of the simulation.\ntmax::Float64: The final time of the simulation.\ndelta_t::Float64: The time step of the output.\nparam_of_ode::Vector{Float64}: The parameters of the ODE model.\n\nKey argument:\n\nintegrator=KenCarp4(): The chosen solver from the SciML ecosystem for ODE integration, default KenCarp4 algorithm. \n\nOutput:\n\nit returns a standard SciML output (i.e., if sim =ODE_sim(...), then sim.t is the array of times and sim.u is the array of the simulation)\n\n\n\n\n\n","category":"function"},{"location":"api/#Stochastic-simulations","page":"API","title":"Stochastic simulations","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"JMAKi.stochastic_sim","category":"page"},{"location":"api/","page":"API","title":"API","text":"JMAKi.stochastic_sim","category":"page"},{"location":"api/#JMAKi.stochastic_sim","page":"API","title":"JMAKi.stochastic_sim","text":"stochastic_sim(\nmodel::String,\nn_start::Int, \nn_mol_start::Float64, \ntstart::Float64, \ntmax::Float64, \ndelta_t::Float64, \nk_1_val::Float64,\nk_2_val::Float64, \nalpha_val::Float64, \nlambda::Float64, \nn_mol_per_birth::Float64,\nvolume::Float64,\n)\n\nThis function performs a stochastic simulation of a model, considering cell growth and nutrient consumption over time.\n\nArguments:\n\nmodel::String: The model to simulate. Possible options \"Monod\",\"Haldane\",\"Blackman\",\"Tessier\",\"Moser\",\"Aiba-Edwards\", and \"Verhulst\"\nn_start::Int: The number of starting cells.\nn_mol_start::Float64: The starting concentration of the limiting nutrient.\ntstart::Float64: The start time of the simulation.\ntmax::Float64: The final time of the simulation.\ndelta_t::Float64: The time step for the Poisson approximation.\nk_1_val::Float64: The value of parameter k1.\nk_2_val::Float64: The value of the Monod constant.\nalpha_val::Float64: The maximum possible growth rate.\nlambda::Float64: The lag time, simulated as a zero growht time span at the start\nn_mol_per_birth::Float64: The nutrient consumed per division (mass).\nvolume::Float64: The volume.\n\nOutput (if sim =stochastic_sim(...)):\n\nsim[1]: array of the number of individuals in the population.\nsim[2]: array of the number of biomass equivalent mass of the limiting nutrient concentration.\nsim[3]: array of the times of the simulation. \n\n\n\n\n\n","category":"function"},{"location":"api/#Various","page":"API","title":"Various","text":"","category":"section"},{"location":"api/","page":"API","title":"API","text":"JMAKi.specific_gr_evaluation","category":"page"},{"location":"api/","page":"API","title":"API","text":"JMAKi.specific_gr_evaluation","category":"page"},{"location":"api/#JMAKi.specific_gr_evaluation","page":"API","title":"JMAKi.specific_gr_evaluation","text":"specific_gr_evaluation(data_smooted::Any, \npt_smoothing_derivative::Int)\n\nFunction that evalauates specific gr evaluation with slinding window log-lin fitting\n\nArguments:\n\n'datasmooted':  matrix of data 2xntime points, it is a single curve.\n'ptsmoothingderivative': Int size of the win, if <2 the the numerical derivative of (log) data is evaluate with interpolation algorithm\n\nOutput:\n\n'specific_gr' an array with the specific growth rate \n\n\n\n\n\n","category":"function"},{"location":"03_main/#API","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"","category":"section"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Simulate ODE\nStochastic simulation\nPlotting a dataset from file\nSpecific growth rate evaluation\nFitting growth rate with log-lin fitting for one well\nFitting growth rate with log-lin fitting for one file\nFitting ODE function for one well\nFitting ODE function for one file\nFitting custom ODE function\nSensitivity analysis\nModel selection\nChange points detection\nFitting segmented ODE with fixed change-point number\nFitting segmented ODE with direct search for a maximum number of change-points","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"<a name=\"simulating-ODE\"></a>","category":"page"},{"location":"03_main/#Simulate-ODE","page":"The main functions of JMAKi","title":"Simulate ODE","text":"","category":"section"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"\n   ODE_sim(model::String, \n    n_start::Vector{Float64}, \n    tstart::Float64, \n    tmax::Float64, \n    delta_t::Float64, \n    param_of_ode::Vector{Float64}; \n    integrator = KenCarp4() \n)","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"This function performs an ODE simulation of a model, considering the initial conditions, time range, and integration parameters.","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Arguments:","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"model::String: The model to simulate.\nn_start::Vector{Float64}: The starting conditions.\ntstart::Float64: The start time of the simulation.\ntmax::Float64: The final time of the simulation.\ndelta_t::Float64: The time step of the output.\nparam_of_ode::Vector{Float64}: The parameters of the ODE model.","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Key argument:","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"integrator=KenCarp4(): The chosen solver from the SciML ecosystem for ODE integration, default KenCarp4 algorithm.","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Output:","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"it returns a standard SciML output (i.e., if sim =ODE_sim(...), then sim.t is the array of times and sim.u is the array of the simulation)","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"<a name=\"simulating-stochastic\"></a>","category":"page"},{"location":"03_main/#Stochastic-simulation","page":"The main functions of JMAKi","title":"Stochastic simulation","text":"","category":"section"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"    stochastic_sim(model::String,\n         n_start::Int,\n         n_mol_start::Float64,\n        tstart::Float64,\n        tmax::Float64,\n        delta_t::Float64,\n        k_1_val::Float64,\n        k_2_val::Float64,\n        alpha_val::Float64,\n        lambda::Float64,\n        n_mol_per_birth::Float64,\n        volume::Float64)","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"This function performs a stochastic simulation of a model, considering cell growth and nutrient consumption over time.","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Arguments:","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"model::String: The model to simulate. PUT the options\nn_start::Int: The number of starting cells.\nn_mol_start::Float64: The starting concentration of the limiting nutrient.\ntstart::Float64: The start time of the simulation.\ntmax::Float64: The final time of the simulation.\ndelta_t::Float64: The time step for the Poisson approximation.\nk_1_val::Float64: The value of parameter k1.\nk_2_val::Float64: The value of the Monod constant.\nalpha_val::Float64: The maximum possible growth rate.\nlambda::Float64: The lag time.\nn_mol_per_birth::Float64: The nutrient consumed per division (mass).\nvolume::Float64: The volume.","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Output (if sim =stochastic_sim(...)):","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"sim[1]: array of the number of individuals in the population.\nsim[2]: array of the number of biomass equivalent mass of the limiting nutrient concentration.\nsim[3]: array of the times of the simulation. ","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"<a name=\"plot-file\"></a>","category":"page"},{"location":"03_main/#Plotting-a-dataset-from-file","page":"The main functions of JMAKi","title":"Plotting a dataset from file","text":"","category":"section"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"plot_data( label_exp::String, \n    path_to_data::String, \n    path_to_annotation::String;\n    path_to_plot=\"NA\", \n    display_plots=true ,\n    save_plot=false, \n    overlay_plots=true, \n    blank_subtraction=\"NO\", \n    average_replicate=false, \n    correct_negative=\"thr_correction\", \n    thr_negative=0.01,\n    )\n    ","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"This function plot all the data from .csv file Arguments:","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"path_to_data::String: The path to the .csv of data\npath_to_annotation::String: The path to the .csv of annotation \nname_well::String: The name of the well.\nlabel_exp::String: The label of the experiment.","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Key Arguments:","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"path_to_plot= \"NA\": Path to save the plots.\nsave_plot=false : save the plot or not\ndisplay_plots=true: Whether or not diplay the plot in julia\noverlay_plots =true : true on plot for all dataset false one plot per well\nverbose=false: Whether to enable verbose output.\npt_avg=7: Number of points to use for smoothing average.\nblank_subtraction=\"NO\": \naverage_replicate=false\nmultiple_scattering_correction=false: Whether or not correct the data qith a calibration curve.\ncalibration_OD_curve=\"NA\": The path where the .csv calibration data are located, used only if multiple_scattering_correction=true.","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Output:","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"For this function the output are saved or displayed depending on the values of key arguments.","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"<a name=\"Specific-growth-rate-evaluation\"></a>","category":"page"},{"location":"03_main/#Specific-growth-rate-evaluation","page":"The main functions of JMAKi","title":"Specific growth rate evaluation","text":"","category":"section"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"specific_gr_evaluation(data_smooted::Matrix{Float64},\n     pt_smoothing_derivative::Int)","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"This function evaluate the specific growth rate of a growth curve","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Arguments:","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"data_smooted::Matrix{Float64}: The dataset with the growth curve, where the first row represents times, and the second row represents the variable to fit (e.g., OD), see data formatting.\npt_smoothing_derivative::Int Number of points for evaluation of specific growth rate. If <2 it uses interpolation algorithm otherwise a sliding window approach.","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"<a name=\"log-lin-one-well\"></a>","category":"page"},{"location":"03_main/#Fitting-growth-rate-with-log-lin-fitting-for-one-well","page":"The main functions of JMAKi","title":"Fitting growth rate with log-lin fitting for one well","text":"","category":"section"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":" fitting_one_well_Log_Lin(data::Matrix{Float64}, \n    name_well::String, \n    label_exp::String; \n    do_plot=false,\n    path_to_plot=\"NA\", \n    type_of_smoothing=\"rolling_avg\",\n    pt_avg=7, \n    pt_smoothing_derivative=7, \n    pt_min_size_of_win=7, \n    type_of_win=\"maximum\", \n    threshold_of_exp=0.9, \n    multiple_scattering_correction=false,\n    calibration_OD_curve =\"NA\" \n    )","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"This function fits a logarithmic-linear model to a single well's data and performs analysis such as plotting and error calculation. Arguments:","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"data::Matrix{Float64}: The dataset with the growth curve, where the first row represents times, and the second row represents the variable to fit (e.g., OD), see data formatting.\nname_well::String: The name of the well.\nlabel_exp::String: The label of the experiment.","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Key Arguments:","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"do_plot=true: Whether to generate and save plots.\npath_to_plot=\"NA\": The path to save the plots, used only if do_plot=true.\npt_avg=7: The number of points to do rolling average smoothing.\npt_smoothing_derivative=7:  Number of points for evaluation of specific growth rate. If <2 it uses interpolation algorithm otherwise a sliding window approach.\npt_min_size_of_win=7: The minimum size of the exponential windows in the number of smoothed points.\ntype_of_win=\"maximum\": How the exponential phase window is selected (\"maximum\" or \"global_thr\").\nthreshold_of_exp=0.9: The threshold of the growth rate in quantile to define the exponential windows.\nmultiple_scattering_correction=false: Whether or not correct the data qith a calibration curve.\ncalibration_OD_curve=\"NA\": The path where the .csv calibration data are located, used only if multiple_scattering_correction=true.","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Output:","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"an array with the following contents:","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"results_lin_log_fit = [label_exp, name_well, start of exp win,  end of exp win,  start of exp win, Maximum specific GR ,specific GR,  2 sigma  CI of GR, doubling time,doubling time - 2 sigma ,doubling time + 2 sigma  , intercept log-lin fitting, 2 sigma intercept ,R^2]","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"The plots of the log-linear fitting and of the dynamics of specific growth rate if do_plot=true","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"<a name=\"log-lin-file\"></a>","category":"page"},{"location":"03_main/#Fitting-growth-rate-with-log-lin-fitting-for-one-file","page":"The main functions of JMAKi","title":"Fitting growth rate with log-lin fitting for one file","text":"","category":"section"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"    fit_one_file_Log_Lin(\n    label_exp::String, \n    path_to_data::String,\n    path_to_annotation::String;\n    path_to_results = \"NA\",\n    path_to_plot= \"NA\",\n    do_plot=false, \n    verbose=false,\n    write_res=false, \n    type_of_smoothing=\"rolling_avg\", \n    pt_avg=7,\n    pt_smoothing_derivative=7, \n    pt_min_size_of_win=7, \n    type_of_win=\"maximum\", \n    threshold_of_exp=0.9, \n    blank_subtraction=\"avg_blank\", \n    fit_replicate=false, \n    correct_negative=\"thr_correction\",\n    thr_negative=0.01, \n    multiple_scattering_correction=false, \n    calibration_OD_curve=\"NA\" \n    )","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"This function fits a logarithmic-linear model to a single file's data.  Arguments:","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"label_exp::String: Label of the experiment.\npath_to_data::String: Path to the folder containing the data.\npath_to_annotation::String: Path to the annotation of the wells.","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Key Arguments:","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"path_to_results= \"NA\": Path to save the results.\npath_to_plot= \"NA\": Path to save the plots.\ndo_plot=false: Whether to generate and visualize plots of the data.\nverbose=false: Whether to enable verbose output.\nwrite_res= false: Whether to write results.\npt_avg=7: Number of points to use for smoothing average.\npt_smoothing_derivative=7:  Number of points for evaluation of specific growth rate. If <2 it uses interpolation algorithm otherwise a sliding window approach.\npt_min_size_of_win=7: Minimum size of the exponential windows in number of smoothed points.\ntype_of_win=\"maximum: How the exponential phase window is selected (\"maximum\" or \"global_thr\").\nthreshold_of_exp=0.9: Threshold of growth rate in quantile to define the exponential windows.\nblank_subtraction=\"avg_blank\": How to use blank data for subtraction (options: \"NO\", \"avgsubtraction\", \"timeavg\").\nfit_replicate=false: If true, fit the average between replicates; if false, fit all replicates independently.\ncorrect_negative=\"thr_correction: Method to correct negative values (options: \"thrcorrection\", \"blankcorrection\").\nthr_negative=0.01: Threshold value used only if correct_negative == \"thr_correction\".\nmultiple_scattering_correction=false: Whether or not correct the data with a calibration curve.\ncalibration_OD_curve=\"NA\": The path where the .csv calibration data are located, used only if multiple_scattering_correction=true.","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Output:","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"a matrix wich each column has  the following contents:","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"results_lin_log_fit[:,1] = [label_exp, name_well, start of exp win,  end of exp win,  start of exp win, Maximum specific GR ,specific GR,  2 sigma  CI of GR, doubling time,doubling time - 2 sigma ,doubling time + 2 sigma  , intercept log-lin fitting, 2 sigma intercept ,R^2]. It can be saved into a .csv if write_res=true.","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"The plots of the log-linear fitting and of the dynamics of specific growth rate if do_plot=true","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"<a name=\"ODE-one-well\"></a>","category":"page"},{"location":"03_main/#Fitting-ODE-function-for-one-well","page":"The main functions of JMAKi","title":"Fitting ODE function for one well","text":"","category":"section"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":" fitting_one_well_ODE_constrained(data::Matrix{Float64},\n    name_well::String, \n    label_exp::String,\n    model::String,\n    lb_param::Vector{Float64}, \n    ub_param::Vector{Float64}; \n    param= lb_param .+ (ub_param.-lb_param)./2,\n    optmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited(), \n    integrator =KenCarp4(autodiff=true), \n    do_plot=false, \n    path_to_plot=\"NA\", \n    pt_avg=1, \n    pt_smooth_derivative=7,\n    smoothing=false,\n    type_of_loss=\"RE\",\n    blank_array=zeros(100),\n    multiple_scattering_correction=false, \n    calibration_OD_curve=\"NA\" ,\n PopulationSize =100,\n          maxiters = 10000,\n           abstol = 0.001\n    )","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"This function performs constrained parameter fitting on a single well's dataset using an ordinary differential equation (ODE) model. It estimates the model parameters within specified lower and upper bounds.","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Arguments:","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"data::Matrix{Float64}: The dataset with the growth curve, where the first row represents times, and the second row represents the variable to fit (e.g., OD), see data formatting.\nmodel::String: ODE model to use\nname_well::String: Name of the well.\nlabel_exp::String: Label of the experiment.\nlb_param::Vector{Float64}: Lower bounds of the model parameters.\nub_param::Vector{Float64}: Upper bounds of the model parameters.","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Key Arguments:","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"param= lb_param .+ (ub_param.-lb_param)./2: Initial guess for the model parameters.\n`integrator =KenCarp4(autodiff=true)' sciML integrator\noptmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited() optimizer from optimizationBBO\ndo_plot=true: Whether to generate plots or not.\npath_to_plot=\"NA\": Path to save the plots.\npt_avg=7: Number of points to generate the initial condition or do the rolling avg smoothing.\nsmoothing=false: Whether to apply smoothing to the data or not.\ntype_of_loss:=\"RE\": Type of loss function to be used. (options= \"RE\", \"L2\", \"L2derivative\" and \"blankweighted_L2\")\nblank_array=zeros(100): Data of all blanks in single array.\nverbose=false: Whether to enable verbose output.\nwrite_res=true: Whether to write results.\nmultiple_scattering_correction=false: Whether or not correct the data qith a calibration curve.\ncalibration_OD_curve=\"NA\": The path where the .csv calibration data are located, used only if multiple_scattering_correction=true.\nPopulationSize =100: Size of the population of the optimization\nmaxiters = 10000: stop criterion, the optimization is stopped when the number of iteration is bigger than abstol\nabstol = 0.001: stop criterion, the optimization is stopped when the loss is lesser than abstol","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Output (if results_ODE_fit =fitting_one_well_ODE_constrained(...):","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"results_ODE_fit[1] an array with the following contents: [\"name of model\", \"well\", \"param_1\",\"param_2\",..,\"param_n\",\"maximum specific gr using ode\",\"maximum specific gr using data\", \"objective function value (i.e. loss of the solution)\"]","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"where ' \"param1\",\"param2\",..,\"paramn\" ' are the parameter of the selected ODE as in this [table](#ODElist)","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"results_ODE_fit[2] the times of the fitted ODE\nresults_ODE_fit[3] the numerical solution of the fitted ODE\nThe plot of the  fitting  if do_plot=true","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"<a name=\"ODE-file\"></a>","category":"page"},{"location":"03_main/#Fitting-ODE-function-for-one-file","page":"The main functions of JMAKi","title":"Fitting ODE function for one file","text":"","category":"section"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"   fit_file_ODE(\n    label_exp::String,\n    path_to_data::String,\n    path_to_annotation::String,\n    model::String, \n    lb_param::Vector{Float64},\n    ub_param::Vector{Float64}; \n    optmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited(),\n    integrator = KenCarp4(autodiff=true), \n    path_to_results=\"NA\",\n    path_to_plot=\"NA\", \n    loss_type=\"RE\", \n    smoothing=false, \n    do_plot=false,\n    verbose=false, \n    write_res=false, \n    pt_avg=1, \n    pt_smooth_derivative=7,\n    blank_subtraction=\"avg_blank\", \n    fit_replicate=false, \n    correct_negative=\"thr_correction\",\n    thr_negative=0.01, \n    multiple_scattering_correction=false, \n    calibration_OD_curve=\"NA\" ,\n   PopulationSize =100,\n          maxiters = 10000,\n           abstol = 0.001 \n    )","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"This function fits an ordinary differential equation (ODE) model to a single file's data. ","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Arguments:","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"path_to_data::String: path to the csv file of data\npath_to_annotation::String path to the annotation of the dataset\nmodel::String: ODE model to use\nlabel_exp::String: Label of the experiment.\nlb_param::Vector{Float64}: Lower bounds of the model parameters.\nub_param::Vector{Float64}: Upper bounds of the model parameters.","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Key Arguments:","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"param= lb_param .+ (ub_param.-lb_param)./2: Initial guess for the model parameters.\n`integrator =KenCarp4(autodiff=true)' sciML integrator\noptmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited() optimizer from optimizationBBO\ndo_plot=true: Whether to generate plots or not.\npath_to_plot=\"NA\": Path to save the plots.\npt_avg=7: Number of points to generate the initial condition or do the rolling avg smoothing.\nsmoothing=false: Whether to apply smoothing to the data or not.\ntype_of_loss:=\"RE\": Type of loss function to be used. (options= \"RE\", \"L2\", \"L2derivative\" and \"blankweighted_L2\")\nblank_array=zeros(100): Data of all blanks in single array.\nverbose=false: Whether to enable verbose output.\nwrite_res=true: Whether to write results.\nmultiple_scattering_correction=false: Whether or not correct the data qith a calibration curve.\ncalibration_OD_curve=\"NA\": The path where the .csv calibration data are located, used only if multiple_scattering_correction=true.\nfit_replicate=false,  if true the average between replicates is fitted.\nPopulationSize =100: Size of the population of the optimization\nmaxiters = 10000: stop criterion, the optimization is stopped when the number of iteration is bigger than abstol\nabstol = 0.001: stop criterion, the optimization is stopped when the loss is lesser than abstol","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Output (if results_ODE_fit =fit_file_ODE(...):","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"results_ODE_fit[1] a matrix with the following contents for each column: [\"name of model\", \"well\", \"param_1\",\"param_2\",..,\"param_n\",\"maximum specific gr using ode\",\"maximum specific gr using data\", \"objective function value (i.e. loss of the solution)\"]. It can be saved into a .csv if write_res=true.","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"where ' \"param1\",\"param2\",..,\"paramn\" ' are the parameter of the selected ODE as in this [table](#ODElist)","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"The plot of the  fitting  if do_plot=true","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"<a name=\"custom-ODE\"></a>","category":"page"},{"location":"03_main/#Fitting-custom-ODE-function-for-one-well","page":"The main functions of JMAKi","title":"Fitting custom ODE function for one well","text":"","category":"section"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"fitting_one_well_custom_ODE(data::Matrix{Float64},\n    name_well::String, \n    label_exp::String,\n    model::Any, \n    lb_param::Vector{Float64}, \n    ub_param::Vector{Float64},\n    n_equation::Int; \n    param= lb_param .+ (ub_param.-lb_param)./2,\n    optmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited(), \n    integrator =KenCarp4(autodiff=true),\n    do_plot=false, \n    path_to_plot=\"NA\", \n    pt_avg=1, \n    pt_smooth_derivative=7,\n    smoothing=false, \n    type_of_loss=\"RE\", \n    blank_array=zeros(100), \n    multiple_scattering_correction=false,\n    calibration_OD_curve=\"NA\"  ,\n   PopulationSize =100,\n          maxiters = 10000,\n           abstol = 0.001\n    )","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"This function is designed for fitting an ordinary differential equation (ODE) model to a dataset representing the growth curve of a microorganism in a well. It utilizes a customizable ODE model, optimization methods, and integration techniques for parameter estimation.","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Arguments:","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"data::Matrix{Float64}: The dataset with the growth curve, where the first row represents times, and the second row represents the variable to fit (e.g., OD), see data formatting.\nname_well::String: The name of the well.\nlabel_exp::String: The label of the experiment.\nmodel::Any: The ODE model to use.\nlb_param::Vector{Float64}: Lower bounds for the parameters.\nub_param::Vector{Float64}: Upper bounds for the parameters.\nn_equation::Int: The number of ODEs in the system.","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Output (if results_ODE_fit =fitting_one_well_custom_ODE(...):","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"results_ODE_fit[1] a matrix with the following contents for each column: [\"name of model\", \"well\", \"param_1\",\"param_2\",..,\"param_n\",\"maximum specific gr using ode\",\"maximum specific gr using data\", \"objective function value (i.e. loss of the solution)\"]. It can be saved into a .csv if write_res=true.","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"where ' \"param1\",\"param2\",..,\"paramn\" ' are the parameter of the selected ODE as in this [table](#ODElist)","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"The plot of the  fitting  if do_plot=true","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Key   Arguments:","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"param= lb_param .+ (ub_param.-lb_param)./2: Initial guess for the parameters.\noptmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(): The optimization method to use.\nintegrator=KenCarp4(autodiff=true): The integrator for solving the ODE.\ndo_plot=false: Whether to generate plots or not.\npath_to_plot=\"NA\": Path to save the generated plots.\npt_avg=1: Number of points to generate the initial condition or do the rolling avg smoothing.\npt_smooth_derivative=7: Number of points for evaluation of specific growth rate. If <2 it uses interpolation algorithm otherwise a sliding window approach.\nsmoothing=false: Determines whether smoothing is applied to the data.\ntype_of_loss=\"RE\": Type of loss used for optimization (options= \"RE\", \"L2\", \"L2derivative\" and \"blankweighted_L2\")\nblank_array=zeros(100): Data representing blanks for correction.\nmultiple_scattering_correction=false: If true, uses a given calibration curve to correct the data.\ncalibration_OD_curve=\"NA\": The path to the calibration curve used for data correction.\nPopulationSize =100: Size of the population of the optimization\nmaxiters = 10000: stop criterion, the optimization is stopped when the number of iteration is bigger than abstol\nabstol = 0.001: stop criterion, the optimization is stopped when the loss is lesser than abstol","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"<a name=\"Sensitivity-analysis\"></a>","category":"page"},{"location":"03_main/#Sensitivity-analysis","page":"The main functions of JMAKi","title":"Sensitivity analysis","text":"","category":"section"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":" one_well_morris_sensitivity(data::Matrix{Float64}, \n    name_well::String,\n    label_exp::String, \n    model::String, \n    lb_param::Vector{Float64}, \n    ub_param::Vector{Float64}; \n    N_step_morris =7,\n    optmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited(), \n    integrator =KenCarp4(autodiff=true), \n    pt_avg=1, \n    pt_smooth_derivative=7,\n    write_res=false,\n    smoothing=false,\n    type_of_loss=\"RE\", \n    blank_array=zeros(100),\n    multiple_scattering_correction=false, \n    calibration_OD_curve=\"NA\"  ,\n   PopulationSize =100,\n          maxiters = 10000,\n           abstol = 0.001\n    )","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"This function is designed to perform Morris sensitivity analysis on a dataset representing the growth curve of a microorganism in a well. It assesses the sensitivity of the model to variations in input parameters of the optimization.","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Arguments:","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"data::Matrix{Float64}: The dataset with the growth curve, where the first row represents times, and the second row represents optical density (OD).\nname_well::String: The name of the well.\nlabel_exp::String: The label of the experiment.\nmodel::String: The ODE model to use.\nlb_param::Vector{Float64}: Lower bounds for the parameters.\nub_param::Vector{Float64}: Upper bounds for the parameters.","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Key Arguments:","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"N_step_morris=7: Number of steps for the Morris sensitivity analysis.\noptmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(): The optimization method to use.\nintegrator=KenCarp4(autodiff=true): The integrator for solving the ODE.\npt_avg=1: Number of points to generate the initial condition or do the rolling avg smoothing.\npt_smooth_derivative=7: Number of points for evaluation of specific growth rate. If <2 it uses interpolation algorithm otherwise a sliding window approach.\nwrite_res=false: If true, writes the sensitivity analysis results to a file.\nsmoothing=false: Determines whether smoothing is applied to the data.\ntype_of_loss=\"RE\": Type of loss used for optimization (options= \"RE\", \"L2\", \"L2derivative\" and \"blankweighted_L2\")\nblank_array=zeros(100): Data representing blanks for correction.\nmultiple_scattering_correction=false: If true, uses a given calibration curve to correct the data.\ncalibration_OD_curve=\"NA\": The path to the calibration curve used for data correction.\nPopulationSize =100: Size of the population of the optimization\nmaxiters = 10000: stop criterion, the optimization is stopped when the number of iteration is bigger than abstol\nabstol = 0.001: stop criterion, the optimization is stopped when the loss is lesser than abstol","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Output (if results_ODE_morris_sensitivity =one_well_morris_sensitivity(...):","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"results_ODE_morris_sensitivity[1] a with in each column the initial guess for the parameters of the optimization in the same order of table\nresults_ODE_morris_sensitivity[2] a matrix with the following contents for each column: [\"name of model\", \"well\", \"param_1\",\"param_2\",..,\"param_n\",\"maximum specific gr using ode\",\"maximum specific gr using data\", \"objective function value (i.e. loss of the solution)\"]. It can be saved into a .csv if write_res=true.","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"where ' \"param1\",\"param2\",..,\"paramn\" ' are the parameter of the selected ODE as in this [table](#ODElist)","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"The plot of the  fitting  if do_plot=true","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"<a name=\"Model-selection\"></a>","category":"page"},{"location":"03_main/#Model-selection","page":"The main functions of JMAKi","title":"Model selection","text":"","category":"section"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"ODE_Model_selection(data::Matrix{Float64}, \n    name_well::String, \n    label_exp::String,\n    models_list::Vector{String}, \n    lb_param_array::Any,\n    ub_param_array::Any; \n    optmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited(), \n    integrator = KenCarp4(autodiff=true), \n    pt_avg = 1 , \n    beta_penality = 2.0, \n    smoothing= false, \n    type_of_loss=\"L2\",\n    blank_array=zeros(100), \n    plot_best_model=false, \n    path_to_plot=\"NA\",\n    pt_smooth_derivative=7,\n    multiple_scattering_correction=false, \n    calibration_OD_curve=\"NA\", \n    verbose=false,\n   PopulationSize =100,\n          maxiters = 10000,\n           abstol = 0.001\n)","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"This function performs model selection based on a dataset representing the growth curve of a microorganism in a well. It evaluates multiple ODE models and selects the best-fitting model using the Akaike Information Criterion (AIC).","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Arguments:","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"data::Matrix{Float64}: The dataset with the growth curve, where the first row represents times, and the second row represents optical density (OD).\nname_well::String: The name of the well.\nlabel_exp::String: The label of the experiment.\nmodels_list::Vector{String}: A vector of ODE models to evaluate.\nlb_param_array::Any: Lower bounds for the parameters (compatible with the models).\nub_param_array::Any: Upper bounds for the parameters (compatible with the models).","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Key Arguments:","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"optmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(): The optimization method to use.\nintegrator=KenCarp4(autodiff=true): The integrator for solving the ODE.\npt_avg=1: Number of points to generate the initial condition or do the rolling avg smoothing.\nbeta_penality=2.0: Penalty for AIC evaluation.\nsmoothing=false: Determines whether smoothing is applied to the data.\ntype_of_loss=\"L2\": Type of loss used for optimization (options= \"RE\", \"L2\", \"L2derivative\" and \"blankweighted_L2\")\nblank_array=zeros(100): Data representing blanks for correction.\nplot_best_model=false: If true, the results of the best-fit model will be plotted.\npath_to_plot=\"NA\": Path to save the generated plots.\npt_smooth_derivative=7: Number of points for evaluation of specific growth rate. If <2 it uses interpolation algorithm otherwise a sliding window approach.\nmultiple_scattering_correction=false: If true, uses a given calibration curve to correct the data.\ncalibration_OD_curve=\"NA\": The path to the calibration curve used for data correction.\nverbose=false: If true, enables verbose output.\nPopulationSize =100: Size of the population of the optimization\nmaxiters = 10000: stop criterion, the optimization is stopped when the number of iteration is bigger than abstol\nabstol = 0.001: stop criterion, the optimization is stopped when the loss is lesser than abstol","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Output (if Model_selection =ODE_Model_selection(...):","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Model_selection[1] a Matrix containing the loss and the AIC score for each model.\nModel_selection[2] a Tuple containing all the fitted models.\nModel_selection[3] the AIC score of the best model\nModel_selection[4] , the loss of the best model\nModel_selection[5] , the parameter of the best model\nModel_selection[6] , the string of the best model\nModel_selection[7] , the numerical solution of the fitted ODE\nThe plot of the  fitting of the best model if do_plot=true","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"<a name=\"cdp\"></a>","category":"page"},{"location":"03_main/#Change-point-detection","page":"The main functions of JMAKi","title":"Change point detection","text":"","category":"section"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"cpd_local_detection(data::Matrix{Float64},\n    n_max_cp::Int;\n    type_of_detection=\"lsdd\",\n    type_of_curve=\"original\", \n    pt_derivative = 0,\n    size_win =2,\nmethod= \"peaks_prominence\",\nnumber_of_bin = 40)\n","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"This function performs change point detection on a dataset, identifying local changes in the growth curve. It uses various algorithms based on user-defined parameters.","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Arguments:","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"data::Matrix{Float64}: The dataset with the growth curve, where the first row represents times, and the second row represents optical density (OD).\nn_max_cp::Int: The maximum number of change points to detect.","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Key Arguments:","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"type_of_detection=\"lsdd\": Type of change point detection algorithm. Options are \"lsdd\" or piecewise linear fitting \ntype_of_curve=\"deriv\": Type of curve used for the change point detection. Options are \"deriv\" for the  derivative/specific gr or \"original\" for growth curve.\npt_derivative=0: Number of points to evaluate the derivative or specific growth rate. If 0, numerical derivative is used; if >1, specific growth rate is calculated with the given window size.\nsize_win=2: Size of the sliding window used in all detection methods.\nmethod = \"peaks_prominence\" : method to detect peak on the dissimilarity curve. Option \"peaksprominence\" use prominece of peaks to score them. `\"thrscan\"` grid scan with a threshold to detect peaks.\nnumber_of_bin = 40: number of bins for the grid search. used only if method = \"thr_scan\"","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Output (if cdps =cpd_local_detection(...):","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"cdps[1] Indexes of the detected change points","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"<a name=\"cdp-fixed\"></a>","category":"page"},{"location":"03_main/#Fitting-segmented-ODE-with-fixed-change-point-number","page":"The main functions of JMAKi","title":"Fitting segmented ODE with fixed change-point number","text":"","category":"section"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"selection_ODE_fixed_change_points(data_testing::Matrix{Float64}, \n    name_well::String,\n    label_exp::String,\n    list_of_models::Vector{String}, \n    list_lb_param::Any,\n    list_ub_param::Any, \n    n_change_points::Int;\n    type_of_loss=\"L2\", \n    optmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited(), \n    integrator = KenCarp4(autodiff=true), \n    type_of_detection =  \"lsdd\",\n    type_of_curve = \"original\", \n    smoothing=false,\n    pt_avg=1,\n    do_plot=false, \n    path_to_plot=\"NA\", \n    win_size=2, \n    pt_smooth_derivative=0,\n    multiple_scattering_correction=false, \n    calibration_OD_curve=\"NA\",\n    beta_smoothing_ms = 2.0,\nmethod_peaks_detection= \"peaks_prominence\",\nn_bins = 40,\n   PopulationSize =100,\n          maxiters = 10000,\n           abstol = 0.001\n    )","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"This function performs model selection for ordinary differential equation (ODE) models while considering fixed change points in a growth curve dataset. It allows for the evaluation of multiple ODE models and considers a specified number of change points.","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Arguments:","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"data_testing::Matrix{Float64}: The dataset with the growth curve, where the first row represents times, and the second row represents optical density (OD).\nname_well::String: The name of the well.\nlabel_exp::String: The label of the experiment.\nlist_of_models::Vector{String}: A vector of ODE models to evaluate.\nlist_lb_param::Any: Lower bounds for the parameters (compatible with the models).\nlist_ub_param::Any: Upper bounds for the parameters (compatible with the models).","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Key Arguments:","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"n_change_points::Int: The number of fixed change points to consider.\ntype_of_loss=\"L2\": Type of loss used for optimization(options= \"RE\", \"L2\", \"L2derivative\" and \"blankweighted_L2\").\noptmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(): The optimization method to use.\nintegrator=KenCarp4(autodiff=true): The integrator for solving the ODE.\ntype_of_detection=\"lsdd\": Type of change point detection algorithm. Options are \"lsdd\" or piecewise linear fitting \ntype_of_curve=\"original\": Type of curve used for the change point detection. Options are \"deriv\" for the  derivative/specific gr or \"original\" for growth curve.\nsmoothing=false: Determines whether smoothing is applied to the data.\npt_avg=1: Number of points to generate the initial condition or do the rolling avg smoothing.\ndo_plot=false: Whether to generate plots or not.\npath_to_plot=\"NA\": Path to save the generated plots.\nwin_size=2: Number of points for the  window of the change point detection algorithm.\npt_smooth_derivative=0: Number of points for evaluation of specific growth rate. If <2 it uses interpolation algorithm otherwise a sliding window approach.\nmultiple_scattering_correction=false: If true, uses a given calibration curve to correct the data.\ncalibration_OD_curve=\"NA\": The path to the calibration curve used for data correction.\nbeta_smoothing_ms=2.0: Penality parameter of the Akaike Information Criterion (AIC) penalty.\nmethod_peaks_detection = \"peaks_prominence\" : method to detect peak on the dissimilarity curve. Option \"peaksprominence\" use prominece of peaks to score them. `\"thrscan\"` grid scan with a threshold to detect peaks.\nn_bins = 40: number of bins for the grid search. used only if method_peaks_detection = \"thr_scan\"\nPopulationSize =100: Size of the population of the optimization\nmaxiters = 10000: stop criterion, the optimization is stopped when the number of iteration is bigger than abstol\nabstol = 0.001: stop criterion, the optimization is stopped when the loss is lesser than abstol","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Output (if res =selection_ODE_fixed_change_points(...):","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"res[1]. Parameters of each segment\nres[2]. Interval of the ODE segment\nres[3]. Time of the fitted solution\nres[4]. Numerical fitted solution\nThe plot of the  fitting if do_plot=true","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"<a name=\"cdp-search\"></a>","category":"page"},{"location":"03_main/#Fitting-segmented-ODE-with-direct-search-for-a-maximum-number-of-change-points","page":"The main functions of JMAKi","title":"Fitting segmented ODE with direct search for a maximum number of change-points","text":"","category":"section"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"ODE_selection_NMAX_change_points(data_testing::Matrix{Float64}, \n    name_well::String, \n    label_exp::String, \n    list_lb_param::Any, \n    list_ub_param::Any, \n    list_of_models::Vector{String}, \n    n_max_change_points::Int; \n    optmizator =   BBO_adaptive_de_rand_1_bin_radiuslimited(),  \n    integrator = KenCarp4(autodiff=true),\n    type_of_loss=\"L2\", # type of used loss \n    type_of_detection =  \"lsdd\",\n    type_of_curve = \"original\", \n    pt_avg = 1 , \n    smoothing= true, \n    do_plot=false, \n    path_to_plot=\"NA\", \n    path_to_results=\"NA\",\n    win_size=2, \n    pt_smooth_derivative=7,\n    penality_parameter=2.0,\n    multiple_scattering_correction=\"false\", \n    calibration_OD_curve=\"NA\",  \n   save_all_model=false,\n    method_peaks_detection= \"peaks_prominence\",\n    n_bins = 40,\n   PopulationSize =100,\n          maxiters = 10000,\n           abstol = 0.001 )","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"This function fits segmented ordinary differential equation (ODE) models to a growth curve dataset using direct search for a maximum number of change-points. It allows for the evaluation of multiple ODE models with a varying number of change-points.","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Arguments:","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"data_testing::Matrix{Float64}: The dataset with the growth curve, where the first row represents times, and the second row represents optical density (OD) or fluorescence.\nname_well::String: The name of the well.\nlabel_exp::String: The label of the experiment.\nlist_lb_param::Any: Lower bounds for the parameters (compatible with the models).\nlist_ub_param::Any: Upper bounds for the parameters (compatible with the models).\nlist_of_models::Vector{String}: A vector of ODE models to evaluate.\nn_max_change_points::Int: The maximum number of change-points to consider.","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Key Arguments:","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"optmizator=BBO_adaptive_de_rand_1_bin_radiuslimited(): The optimization method to use.\nintegrator=KenCarp4(autodiff=true): The integrator for solving the ODE.\ntype_of_loss=\"L2\": Type of loss used for optimization (options: \"L2\" for squared loss).\ntype_of_detection=\"lsdd\": Type of change point detection algorithm. Options are \"lsdd\" for piecewise linear fitting on the specific growth rate.\ntype_of_curve=\"original\": Type of curve used for the change point detection. Options are \"deriv\" for the  derivative/specific gr or \"original\" for growth curve.\npt_avg=1: Number of points to generate the initial condition or do the rolling avg smoothing.\nsmoothing=true: Determines whether smoothing is applied to the data.\ndo_plot=false: Whether to generate plots or not.\npath_to_plot=\"NA\": Path to save the generated plots.\npath_to_results=\"NA\": Path to save the fitting results.\nwin_size=2: Number of points for the  window of the change point detection algorithm.\npt_smooth_derivative=0: Number of points for evaluation of specific growth rate. If <2 it uses interpolation algorithm otherwise a sliding window approach.\npenality_parameter=2.0: Parameter for penalizing the change in the number of parameters.\nmultiple_scattering_correction=false: If true, uses a given calibration curve to correct the data.\ncalibration_OD_curve=\"NA\": The path to the calibration curve used for data correction.\nsave_all_model=false: If true, saves fitting results for all evaluated models.\nmethod_peaks_detection = \"peaks_prominence\" : method to detect peak on the dissimilarity curve. Option \"peaksprominence\" use prominece of peaks to score them. `\"thrscan\"` grid scan with a threshold to detect peaks.\nn_bins = 40: number of bins for the grid search. used only if method_peaks_detection = \"thr_scan\"\nPopulationSize =100: Size of the population of the optimization\nmaxiters = 10000: stop criterion, the optimization is stopped when the number of iteration is bigger than abstol\nabstol = 0.001: stop criterion, the optimization is stopped when the loss is lesser than abstol","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"Output (if res =ODE_selection_NMAX_change_points(...):","category":"page"},{"location":"03_main/","page":"The main functions of JMAKi","title":"The main functions of JMAKi","text":"res[1]. The  parameters of each segment of the top model\nres[2]. Time of the fitted solution\nres[3]. Numerical fitted solution\nThe plot of the  fitting if do_plot=true\nIf save_all_model=true the best segnmented model is saved for each number of change points between 0 and n_max_change_points","category":"page"},{"location":"04_math/#models","page":"The mathematical models","title":"The mathematical models","text":"","category":"section"},{"location":"04_math/","page":"The mathematical models","title":"The mathematical models","text":"ODEs for bacterial growth\n Stochastic models for bacterial growth\nType of loss","category":"page"},{"location":"04_math/#ODEs-for-bacterial-growth","page":"The mathematical models","title":"ODEs for bacterial growth","text":"","category":"section"},{"location":"04_math/","page":"The mathematical models","title":"The mathematical models","text":"The models and their parameters are sumarrized in the following table | Model                                  |  Parameters                                       | | -|| | Diauxicpiecewisedampedlogistic      | gr1, Nmax, shape1, lag, linearconst, tshift, gr2, Nmax2, shape2, endsecondlag, lag2gr | | Diauxicreplicator1                    | gr, Nmax, lag, arbitraryconst, linearconst | | Diauxicreplicator2                    | gr, Nmax, lag, arbitraryconst, linearconst, growthstationary | | HPM                                    | gr, exitlagrate, Nmax | | dHPM                                    | gr, exitlagrate, Nmax,shape | | HPM3death                            | gr, exitlagrate, inactivationrate, deathrate | | HPM3deathresistance                 | gr, exitlagrate, inactivationrate, deathrate, nres, nmax | | HPM3inhibition                       | gr, exitlagrate, inactivationrate | | HPMinhibition                         | gr, inhibitionrate, grinhibition, Nmax | | HPMexp                                | gr, exitlagrate | | ODEsHPMSR                            | gr, grphage, scale, deathrate, resistancerate | | baranyiexp                            | gr, lagtime, shape | | baranyirichards                       | gr, Nmax, lagtime, shape | | baranyiroberts                        | gr, Nmax, lagtime, shape1, shape2 | | bertalanffyrichards                   | gr, Nmax, shape | | exponential                             | gr | | fourpiecewise                          | gr, gr2, gr3, gr4, lag, tdecaygr, tstationary | | gbsmpiecewise                         | gr, a1, b1, c, a2, b2 | | gompertz                               | gr, Nmax | | hypergompertz                         | gr, Nmax, shape | | hyperlogistic                         | doublingtime, gr, Nmax, shape | | huang                                  | gr, Nmax, lag | | logistic                               | gr, Nmax | | logistic                               | gr, Nmax, shape | | odevonbertalanffy                    | alpha, beta, a, b | | piecewisedampedlogistic              | gr, Nmax, lag, shape, linearconst | | triplepiecewise                       | gr, gr2, gr3, lag, tstationary | | triplepiecewisebertalanffyrichards  | gr, grlag, tlag, tstationary, grstat, shape, Nmax | | triplepiecewisedampedlogistic       | gr, gr2, gr3, lag, tstationary, Nmax | | triplepiecewisesublinear             | gr, gr2, gr3, lag, tstationary, N_max |","category":"page"},{"location":"04_math/#Stochastic-models-for-bacterial-growth","page":"The mathematical models","title":"Stochastic models for bacterial growth","text":"","category":"section"},{"location":"04_math/","page":"The mathematical models","title":"The mathematical models","text":"In the stochastic version of the growth models, the growth rate of each population component (denoted as mu_i) is evaluated based on the concentration of the limiting nutrient. The user is required to specify the starting amount of nutrients and the volume of the solution. Various kinetic growth models are considered.","category":"page"},{"location":"04_math/#Monod-Model","page":"The mathematical models","title":"Monod Model","text":"","category":"section"},{"location":"04_math/","page":"The mathematical models","title":"The mathematical models","text":"The Monod model is described by the following equation:","category":"page"},{"location":"04_math/","page":"The mathematical models","title":"The mathematical models","text":"mu(textNut k_1 mu_textmax) = mu_textmax fractextNutk_1 + textNut","category":"page"},{"location":"04_math/#Haldane-Model","page":"The mathematical models","title":"Haldane Model","text":"","category":"section"},{"location":"04_math/","page":"The mathematical models","title":"The mathematical models","text":"The Haldane model is expressed as:","category":"page"},{"location":"04_math/","page":"The mathematical models","title":"The mathematical models","text":"mu(textNut k_1 k_2 mu_textmax) = mu_textmax fractextNutk_1 + textNut + frack_2textNut^2","category":"page"},{"location":"04_math/#Blackman-Model","page":"The mathematical models","title":"Blackman Model","text":"","category":"section"},{"location":"04_math/","page":"The mathematical models","title":"The mathematical models","text":"The Blackman model is given by:","category":"page"},{"location":"04_math/","page":"The mathematical models","title":"The mathematical models","text":"mu(textNut k_1 mu_textmax) = mu_textmax fractextNutk_1 + textNut","category":"page"},{"location":"04_math/#Tessier-Model","page":"The mathematical models","title":"Tessier Model","text":"","category":"section"},{"location":"04_math/","page":"The mathematical models","title":"The mathematical models","text":"The Tessier model is represented as:","category":"page"},{"location":"04_math/","page":"The mathematical models","title":"The mathematical models","text":"mu(textNut k_1 mu_textmax) = mu_textmax (1 - e^k_1textNut )","category":"page"},{"location":"04_math/#Moser-Model","page":"The mathematical models","title":"Moser Model","text":"","category":"section"},{"location":"04_math/","page":"The mathematical models","title":"The mathematical models","text":"The Moser model is defined by:","category":"page"},{"location":"04_math/","page":"The mathematical models","title":"The mathematical models","text":"mu(textNut k_1 k_2 mu_textmax) = mu_textmax fractextNut^k_2k_1 + textNut^k_2","category":"page"},{"location":"04_math/#Aiba-Edwards-Model","page":"The mathematical models","title":"Aiba-Edwards Model","text":"","category":"section"},{"location":"04_math/","page":"The mathematical models","title":"The mathematical models","text":"The Aiba-Edwards model is given by:","category":"page"},{"location":"04_math/","page":"The mathematical models","title":"The mathematical models","text":"mu(textNut k_1 k_2 mu_textmax) = mu_textmax fractextNutk_1 + textNut e^-fractextNutk_2","category":"page"},{"location":"04_math/#Verhulst-Model","page":"The mathematical models","title":"Verhulst Model","text":"","category":"section"},{"location":"04_math/","page":"The mathematical models","title":"The mathematical models","text":"The Verhulst model is defined as:","category":"page"},{"location":"04_math/","page":"The mathematical models","title":"The mathematical models","text":"mu(N N_textmax mu_textmax) = mu_textmax left(1 - fracNN_textmaxright)","category":"page"},{"location":"04_math/","page":"The mathematical models","title":"The mathematical models","text":"Where textNut is the limiting nutrient concentration, mu_textmax is the maximum possible growth rate, k_1 and k_2 are numerical constants with meanings depending","category":"page"},{"location":"04_math/#Type-of-loss-functions","page":"The mathematical models","title":"Type of loss functions","text":"","category":"section"},{"location":"04_math/","page":"The mathematical models","title":"The mathematical models","text":"type_of_loss = \"L2\": Minimize the L2 norm of the difference between the numerical solution of an ODE and the given data.","category":"page"},{"location":"04_math/","page":"The mathematical models","title":"The mathematical models","text":"mathcalD(D(t_i) barN(t_i P)) = left(D(t_i) - barN(t_i P)right)^2","category":"page"},{"location":"04_math/","page":"The mathematical models","title":"The mathematical models","text":"type_of_loss = \"L2_derivative\": Minimize the L2 norm of the difference between the derivatives of the numerical solution of an ODE and the corresponding derivatives of the data.","category":"page"},{"location":"04_math/","page":"The mathematical models","title":"The mathematical models","text":"type_of_loss =\"RE\": Minimize the relative error between the solution and data ","category":"page"},{"location":"04_math/","page":"The mathematical models","title":"The mathematical models","text":"mathcalD(D(t_i) barN(t_i P)) = 05 cdot left(1 - fracD(t_i)barN(t_i P)right)^2","category":"page"},{"location":"04_math/","page":"The mathematical models","title":"The mathematical models","text":"type_of_loss = \"blank_weighted_L2\" : Minimize a weighted version of the L2 norm, where the difference between the solution and data is weighted based on a distribution obtained from empirical blank data. ","category":"page"},{"location":"04_math/","page":"The mathematical models","title":"The mathematical models","text":"mathcalD(D(t_i) barN(t_i P)) = (1 - P(D(t_i) - barN(t_i P)textnoise)) cdot left(D(t_i) - barN(t_i P)right)^2","category":"page"},{"location":"05_examples/#examples","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"","category":"section"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"This section provides some copy-and-paste examples of JMAKi.jl","category":"page"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"Simulating Data with ODEs -Simulating Data with ODEs -Simulating Data with stochastic simulations\nData Preprocessing\nFitting a single kinetics\nLog-Lin fitting\nFitting ODE Models\nCustom ODE Fitting\nSensitivity Analysis\nODE Model Selection\nFitting NL Models\nCustom NL Fitting\nNL Sensitivity Analysis\nNL Model Selection\nODE segmentation\nNL segmentation\nFitting one file (a plate)\nPlot one file\nLog-Lin fitting\nFitting ODE Models\nFitting NL Models\nODE segmentation\nNL segmentation","category":"page"},{"location":"05_examples/#Simulating-Data","page":"Examples and Tutorial","title":"Simulating Data","text":"","category":"section"},{"location":"05_examples/#Simulating-Data-with-ODEs","page":"Examples and Tutorial","title":"Simulating Data with ODEs","text":"","category":"section"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"To simulate data using Ordinary Differential Equations (ODEs):","category":"page"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"# Simulating data with an ODE\nmodel = \"triple_piecewise_damped_logistic\"\nn_start = [0.1]\ntstart = 0.0\ntmax = 600.0\ndelta_t = 10.0\n\nparam_of_ode = [0.06, 1.0, 200, 0.5, 0.001, 450, -0.0002]\n\n# Calling the simulation function\nsim = ODE_sim(model, n_start, tstart, tmax, delta_t, param_of_ode)\n\n# Plotting scatterplot of data\nPlots.scatter(sim, xlabel=\"Time\", ylabel=\"Arb. Units\", label=[\"Data \" nothing], color=:blue, size=(300, 300))","category":"page"},{"location":"05_examples/#Simulating-Data-with-stochastic-simulations","page":"Examples and Tutorial","title":"Simulating Data with stochastic simulations","text":"","category":"section"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"To simulate data using  stochastic models:","category":"page"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"sim =stochastic_sim(\"Monod\", #string of the model\n   1, # number of starting cells\n   10000.1, # starting # molecules (in \"biomass units\") of the limiting nutrients\n    0.0, # start time of the sim\n    2000.0, # final time of the sim\n    0.1, # delta t for poisson approx\n    11.1,\n    10.1, # monod constant\n    0.06, # massimum possible growth rate\n   10.0, # lag time\n    0.0000001,# nutrient consumed per division (conc)\n    1000.0 #volume\n)\nplot(sim[3],sim[1], xlabel=\"Time\",ylabel=\"# of indivuals\")\nplot(sim[3],sim[2], xlabel=\"Time\",ylabel=\"nutrients/volume\")\n\ndata_OD = Matrix(transpose(hcat(sim[3],sim[1])))","category":"page"},{"location":"05_examples/#Data-Preprocessing","page":"Examples and Tutorial","title":"Data Preprocessing","text":"","category":"section"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"We start applying a rolling average smoothing to the data. In the example, a rolling window of size 7 is applied to the original data (data_OD generated in the previous examples). ","category":"page"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"data_ODsmooth = smoothing_data(data_OD, 7)\ndata_ODsmooth = Matrix(data_ODsmooth)\n\n# Plotting scatterplot of smoothed data\nPlots.scatter(data_ODsmooth[1, :], data_ODsmooth[2, :], xlabel=\"Time\", ylabel=\"Arb. Units\", label=[\"Smoothed data \" nothing], markersize=2, color=:blue, size=(300, 300))","category":"page"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"Furthermore, to address potential external influences, a correction for multiple scattering is applied to the smoothed data. This correction is executed through the correctionODmultiplescattering function, requiring an external file (calibrationcurve.csv).  it is  optional in the provided example. ","category":"page"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"\n# Multiple scattering correction (optional, comment out if not needed)\ndata_ODsmooth = correction_OD_multiple_scattering(data_ODsmooth, \"/your_path/calibration_curve.csv\")\n\n# Plotting scatterplot of preprocessed data\nPlots.scatter(data_ODsmooth[1, :], data_ODsmooth[2, :], xlabel=\"Time\", ylabel=\"Arb. Units\", label=[\"Pre-processed data\" nothing], markersize=2, color=:blue, size=(300, 300))","category":"page"},{"location":"05_examples/#Fitting-single-well","page":"Examples and Tutorial","title":"Fitting single well","text":"","category":"section"},{"location":"05_examples/#Log-Lin-fitting","page":"Examples and Tutorial","title":"Log-Lin fitting","text":"","category":"section"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"This code snippet performs log-linear fitting using the fittingonewellLogLin function (of data generated in the previous examples). ","category":"page"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"res_log_lin = fitting_one_well_Log_Lin(\n    data_OD,  # dataset, first row times, second row OD\n    \"test\",           # name of the well\n    \"test\"            # label of the experiment\n)","category":"page"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"The results are stored in the resloglin variable. With the following form","category":"page"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"results_lin_log_fit = [label_exp, name_well, start_exp_win, end_exp_win, time_max_gr ,gr_of_max, gr_log_lin_fitting, 2_sigma_confidence_gr, doubling time , doubling time  - 2 sigma,  doubling time  + 2 sigma, intercept log-lin fitting, ntercept log-lin fitting 2 sigma ,R^2]\n","category":"page"},{"location":"05_examples/#Fitting-ODE-Models","page":"Examples and Tutorial","title":"Fitting ODE Models","text":"","category":"section"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"Before fitting, upper and lower bounds for the ODE parameters are defined ","category":"page"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"\n# Upper bounds of the parameters of the ODE\nub_dhpm = [1.2, 1.1, 2.0, 20]\n\n# Lower bounds of the parameters of the ODE\nlb_dhpm = [0.0001, 0.00000001, 0.00, 0]","category":"page"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"The actual fitting is accomplished through the fittingonewellODEconstrained function. This function takes the  dataset (dataOD generated in the previous examples), the name and label of the well, the ODE model to use (\"dHPM\" in this case), as well as the upper and lower bounds for the ODE parameters. Additionally, the function allows for plotting the results (doplot=true) and specifying the path to save the generated plots (pathtoplot=pathtoplotting).","category":"page"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"# Performing ODE fitting\nresults_ODE_fit = fitting_one_well_ODE_constrained(\n    data_OD, \"\", \"\", \"dHPM\", lb_dhpm, ub_dhpm,\n    do_plot=true, path_to_plot=\"path_to_plotting\"\n)\n","category":"page"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"The results are stored in 'resultsODEfit' with the following format","category":"page"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":" results_ODE_fit = [\"name of model\", \"well\", \"param_1\",\"param_2\",..,\"param_n\",\"maximum specific gr using ode\",\"maximum specific gr using data\", \"objective function value (i.e. loss of the solution)\"]","category":"page"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"where ' \"param1\",\"param2\",..,\"paramn\" ' are the parameter of the selected ODE as in this [table](#ODElist)","category":"page"},{"location":"05_examples/#Custom-ODE-Fitting","page":"Examples and Tutorial","title":"Custom ODE Fitting","text":"","category":"section"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"The custom ODE function (ODE_custom) is defined with specific dynamics tailored to the characteristics of the microbial system. In this example, the function computes the rates of change (du) for two state variables (u) based on the provided parameters (param) and time (t). The specific structure of this function should be adjusted to match the dynamics of the microbial system under investigation.","category":"page"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"\n# Custom ODE function\nfunction ODE_custom(du, u, param, t)\n    du[1] = u[1] * (1 - u[1]) * param[2] + param[1] * u[1]\n    du[2] = u[1] * param[2] + param[4] * u[2] * (1 - (u[1] + u[2]) / param[3])\nend\n","category":"page"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"The upper and lower bounds for the custom ODE parameters (customub and customlb) are defined, and the fitting process is initiated using the fittingonewellcustomODE function. This function takes the  dataset (dataOD  generated in the previous examples), the name and label of the well, the custom ODE function (ODEcustom), and the upper and lower bounds for the ODE parameters. Additionally, the number of ODEs in the system is specified (2 in this example). The results can be visualized through plotting (doplot=true) with the option to save the generated plots (pathtoplot=pathto_plotting).","category":"page"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"# Bounds for the custom ODE parameters\ncustom_ub = [1.2, 1.1, 2.0, 20]\ncustom_lb = [0.0001, 0.00000001, 0.00, 0]\n\n# Performing custom ODE fitting\nresults_ODE_fit = fitting_one_well_custom_ODE(\n    data_OD, \"test\", \"test_model_custom\", ODE_custom,\n    custom_lb, custom_ub, 2,\n    do_plot=true, path_to_plot=path_to_plotting\n)","category":"page"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"The results are stored in 'resultsODEfit' with the same format of the previous examples","category":"page"},{"location":"05_examples/#Sensitivity-Analysis","page":"Examples and Tutorial","title":"Sensitivity Analysis","text":"","category":"section"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"The sensitivity analysis is initiated with the onewellmorrissensitivity function. This function takes the preprocessed dataset (dataOD generated in the previous examples), the name and label of the well, the ODE model to use (\"dHPM\" in this case), as well as the lower and upper bounds for the ODE parameters. The number of steps in the Morris method (nstepsensitivity) is specified to control the granularity of the analysis.","category":"page"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"# Number of steps for Morris sensitivity analysis\nn_step_sensitivity = 3\n\n# Performing Morris sensitivity analysis\nsensitivity_test = one_well_morris_sensitivity(\n    data_OD, \"test\", \"test_sensitivity\", \"dHPM\", lb_dhpm, ub_dhpm,\n    N_step_morris=n_step_sensitivity\n)\n","category":"page"},{"location":"05_examples/#ODE-Model-Selection","page":"Examples and Tutorial","title":"ODE Model Selection","text":"","category":"section"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"Several ODE models are considered for the selection process, each defined by upper (list_ub) and lower (list_lb) bounds for their respective parameters. The models include \"dHPM,\" \"piecewisedampedlogistic,\" \"triplepiecewise,\" and \"baranyiroberts.\"","category":"page"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"# Model candidates and their parameter bounds\nlist_of_models = [\"dHPM\", \"piecewise_damped_logistic\", \"triple_piecewise\", \"baranyi_roberts\"]\n\nub_piece_wise_logistic =[ 0.06 , 2.0 , 500.0 , 10.0 ,  0.001    ]\nlb_piece_wise_logistic =[ 0.0001 , 0.001,0.0  , 0.001 ,  - 0.001  ]\nub_baranyi_roberts =[ 0.06 , 2.0 , 500.0 , 10.0,  10   ]\nlb_baranyi_roberts =[ 0.0001 , 0.001, 0.0 ,  0.01 , 0  ]\nub_triple_exp =[ 1.2 , 0.001 ,  0.2 , 500.0  , 2000   ]\nlb_triple_exp =[ 0.0001 , -0.001, 0.0  , 00.0 ,  200.0   ]\nub_dhpm =[ 1.2 , 1.1 , 2.0  ,20  ]\nlb_dhpm =[ 0.0001 , 0.00000001, 0.00 ,0 ]\n\nlist_ub = [ub_dhpm, ub_piece_wise_logistic, ub_triple_exp, ub_baranyi_roberts]\nlist_lb = [lb_dhpm, lb_piece_wise_logistic, lb_triple_exp, lb_baranyi_roberts]","category":"page"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"The model selection process is initiated with the ODE_Model_selection function. This function takes the preprocessed dataset (data_OD generated in the previous examples), the name and label of the well, the list of models, and their respective upper and lower bounds. Additionally, the function allows for plotting the results of the best-fit model (plot_best_model=true) and specifies the path to save the generated plots (path_to_plot=path_to_plotting). The verbose=true option provides detailed output during the model selection process.","category":"page"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"# Performing model selection\nresults_ms = ODE_Model_selection(\n    data_OD, \"test\", \"test_model_selection\",\n    list_of_models, list_lb, list_ub,\n    plot_best_model=true, path_to_plot=path_to_plotting, verbose=true\n)","category":"page"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"The results of the model selection process are stored in the results_ms variable.","category":"page"},{"location":"05_examples/#Fitting-one-file-(a-plate)","page":"Examples and Tutorial","title":"Fitting one file (a plate)","text":"","category":"section"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"The next three functions work directly on a file. So in this case are mandatory the .csv of data and annotation (see  Data and annotation formatting ). Aslo in XXXXX the user can download an examples of data and annotation.","category":"page"},{"location":"05_examples/#Plot-one-file","page":"Examples and Tutorial","title":"Plot one file","text":"","category":"section"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"The provided code  is an example of plotting experimental data in a .csv file:","category":"page"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"\n# Paths to data, annotation, results, and plots\npath_to_data = \"/example/data_channel_1.csv\"\npath_to_annotation = \"/example/annotation_channel_1_media_M9 + 0.2% Glucose.csv\"\npath_to_plot = \"/example/plots/\"\n\nplot_data(   \"example\", #label of the experiment\n    path_to_data, # path to the folder to analyze\n    path_to_annotation;# path to the annotation of the wells\n    path_to_plot=path_to_plot, # path where to save Plots\n    display_plots=true ,# display plots in julia or not\n    save_plot=true, # save the plot or not\n    overlay_plots=true, # true a single plot for all dataset false one plot per well\n    blank_subtraction=\"avg_blank\" # string on how to use blank (NO,avg_blank,time_avg)\n)","category":"page"},{"location":"05_examples/#Log-Lin-fitting-2","page":"Examples and Tutorial","title":"Log-Lin fitting","text":"","category":"section"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"The provided code  is an example of Log-Lin fitting of experimental data in a .csv file:","category":"page"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"\n# Paths to data, annotation, results, and plots\npath_to_data = \"/example/data_channel_1.csv\"\npath_to_annotation = \"/example/annotation_channel_1_media_M9 + 0.2% Glucose.csv\"\npath_to_results = \"/example/results/\"\npath_to_plot = \"/example/plots/\"\n\nres = fit_one_file_Log_Lin(\n    \"log_lin_WT_CHL_dose_reponse\", #label of the experiment\n    path_to_data, # path to the folder to analyze\n    path_to_annotation;\n  path_to_results = path_to_results,  # path where to save results\n    path_to_plot = path_to_plot,        # path where to save plots\n    do_plot = true,          # do and visualize the plots of data\n    write_res = true,        # write results\n    )","category":"page"},{"location":"05_examples/#Fitting-ODE-Models-2","page":"Examples and Tutorial","title":"Fitting ODE Models","text":"","category":"section"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"The provided code  is an example of fitting a differential equation model to experimental data in a .csv file:","category":"page"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"# Define upper and lower bounds for the parameters of the ODE model\nub_dhpm = [0.1, 0.1, 2.0, 5.0]\nlb_dhpm = [0.001, 0.00001, 0.01, 0.5]\n\n# Paths to data, annotation, results, and plots\npath_to_data = \"/example/data_channel_1.csv\"\npath_to_annotation = \"/example/annotation_channel_1_media_M9 + 0.2% Glucose.csv\"\npath_to_results = \"/example/results/\"\npath_to_plot = \"/example/plots/\"\n\n# Fit the ODE model to the experimental data\nres = fit_file_ODE(\n    \"WT_CHL_dose_reponse\",  # label of the experiment\n    path_to_data,            # path to the data\n    path_to_annotation,      # path to the annotation of the wells\n    \"dHPM\",                   # string of the used model\n    lb_dhpm,                  # array of the lower bound of the parameters\n    ub_dhpm;                 # array of the upper bound of the parameters\n    path_to_results = path_to_results,  # path where to save results\n    path_to_plot = path_to_plot,        # path where to save plots\n    do_plot = true,          # do and visualize the plots of data\n    write_res = true,        # write results\n    pt_avg = 2,              # number of points to do smoothing average\n    PopulationSize = 500,    # population size for optimization\n    maxiters = 500000,       # maximum number of iterations\n    abstol = 0.00000000001   # absolute tolerance for optimization\n)","category":"page"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"This example is fitting an ODE model (specifically the \"dHPM\" model) to experimental data provided in CSV files.","category":"page"},{"location":"05_examples/#ODE-segmentation-with-fixed-number-of-change-points","page":"Examples and Tutorial","title":"ODE segmentation with fixed number of change points","text":"","category":"section"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"In this example, we demonstrate the process of fitting a dataset with a sequence of ODEs using a segmentation approach. The dataset is generated with three segments, each modeled by a different ODE. Then we fit it with the 'selectionODEfixedchangepoints' function","category":"page"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"# First segment ODE\nmodel = \"exponential\"\nn_start = [0.1]\ntstart = 0.0\ntmax = 10.0\ndelta_t = 2.0\nparam_of_ode = [0.00]\nsim_1 = ODE_sim(model, n_start, tstart, tmax, delta_t, integrator, param_of_ode)\nsol_1 = reduce(vcat, sim_1)\n\n# Second segment ODE\nmodel = \"logistic\"\nn_start = [sol_1[end]]\ntstart = 10.0\ntmax = 80.0\ndelta_t = 2.0\nparam_of_ode = [0.2, 0.4]\nsim_2 = ODE_sim(model, n_start, tstart, tmax, delta_t, integrator, param_of_ode)\nsol_2 = reduce(vcat, sim_2)\n\n# Third segment ODE\nmodel = \"logistic\"\nn_start = [sol_2[end]]\ntstart = 80.0\ntmax = 200.0\ndelta_t = 2.0\nparam_of_ode = [0.1, 0.8]\nsim_3 = ODE_sim(model, n_start, tstart, tmax, delta_t, integrator, param_of_ode)\nsol_3 = reduce(vcat, sim_3)\n\n# Concatenating simulations\ntimes_sim = vcat(sim_1.t, sim_2.t)\ntimes_sim = vcat(times_sim, sim_3.t)\nsol_sim = vcat(sol_1, sol_2)\nsol_sim = vcat(sol_sim, sol_3)\n\n# Plotting the generated dataset\nPlots.scatter(sol_sim, xlabel=\"Time\", ylabel=\"Arb. Units\", label=[\"Data \" nothing], color=:blue, size=(300, 300))\n\n# Computing and visualizing the first derivative\ndata_OD = Matrix(transpose(hcat(times_sim, sol_sim)))\nderiv = specific_gr_evaluation(data_OD, 0)\nPlots.scatter(deriv, xlabel=\"Time\", ylabel=\"Arb. Units\", label=[\"Data \" nothing], color=:blue, size=(300, 300))\n\n# Adding uniform noise to the dataset\nnoise_uniform = rand(Uniform(-0.01, 0.01), length(sol_sim))\ndata_OD = Matrix(transpose(hcat(times_sim, sol_sim)))\ndata_OD[2, :] = data_OD[2, :] .+ noise_uniform\n\n# Plotting the noisy dataset\nPlots.scatter(data_OD[1, :], data_OD[2, :], xlabel=\"Time\", ylabel=\"Arb. Units\", label=[\"Data \" nothing], color=:blue, markersize=2, size=(300, 300))\n\n# Initializing all the models for selection\nub_exp = [0.1]\nlb_exp = [-0.01]\nub_logistic = [0.9, 5.0]\nlb_logistic = [0.0001, 0.001]\nub_hpm = [0.1, 20.0, 50.001]\nlb_hpm = [0.0001, 0.000001, 0.001]\nub_hpm_exp = [0.1, 20.0]\nlb_hpm_exp = [0.0001, 0.0000001]\n\nlist_of_models = [\"exponential\", \"HPM\", \"HPM_exp\", \"logistic\"]\nlist_ub_param = [ub_exp, ub_hpm, ub_hpm_exp, ub_logistic]\nlist_lb_param = [lb_exp, lb_hpm, lb_hpm_exp, lb_logistic]\n\n# Fitting with a fixed number of change points\ntest_fixed_cdp = selection_ODE_fixed_change_points(\n    data_OD, \"test\", \"test\", list_of_models, list_lb_param, list_ub_param, 2;\n    do_plot=true, path_to_plot=path_to_plotting, pt_smooth_derivative=0\n)","category":"page"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"results are stored in testfixedcdp.","category":"page"},{"location":"05_examples/#ODE-segmentation","page":"Examples and Tutorial","title":"ODE segmentation","text":"","category":"section"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"Using the same code as the previous example to generate the data the  fit  is performed with ","category":"page"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"# Fitting with direct search on the number of change points\n test_cdp = ODE_selection_NMAX_change_points(data_OD,\n    \"test\",\n    \"test\",\n    list_lb_param,\n    list_ub_param,\n    list_of_models,\n   3;\n    do_plot=true,\n path_to_plot=path_to_plotting,\n pt_smooth_derivative=0)","category":"page"},{"location":"05_examples/","page":"Examples and Tutorial","title":"Examples and Tutorial","text":"results are stored in test_cdp.","category":"page"},{"location":"#JMAKi-Julia-Model-based-Analyses-of-microbial-Kinetics","page":"JMAKi - Julia Model-based Analyses of microbial Kinetics","title":"JMAKi - Julia Model-based Analyses of microbial Kinetics","text":"","category":"section"},{"location":"","page":"JMAKi - Julia Model-based Analyses of microbial Kinetics","title":"JMAKi - Julia Model-based Analyses of microbial Kinetics","text":"<div style=\"text-align: center; margin-bottom: 20px;\">\n    <img alt=\"JMAKi logo\" src=\"./assets/logo.png\">\n</div>","category":"page"},{"location":"","page":"JMAKi - Julia Model-based Analyses of microbial Kinetics","title":"JMAKi - Julia Model-based Analyses of microbial Kinetics","text":"JMAKi (a Julia package for Model-based Analyses of microbial Kinetics) is a versatile software tool that utilizes Ordinary Differential Equations (ODEs) to fit bacterial growth data from plate reader experiments.  With JMAKi it is possible to simulate, fit, perform model selection, and conduct sensitivity analysis for multi-well plate reader experiments. The parameter fitting in JMAKi is defined as a constrained optimization problem, which is solved using a differential evolution box-constrained non-linear optimizer.","category":"page"},{"location":"","page":"JMAKi - Julia Model-based Analyses of microbial Kinetics","title":"JMAKi - Julia Model-based Analyses of microbial Kinetics","text":"To address complex cases,  JMAKi preprocesses data by detecting change points in the differential operator (or in the solution of the ODE) within the time series.  It then automatically assembles and fits a segmented ODE model, resulting in a fully interpretable representation of the time series.","category":"page"},{"location":"","page":"JMAKi - Julia Model-based Analyses of microbial Kinetics","title":"JMAKi - Julia Model-based Analyses of microbial Kinetics","text":"Pages = [\n    \"01_install/index.md\",\n    \"02_data/index.md\",\n    \"04_math/index.md\",\n    \"05_examples/index.md\"\n]","category":"page"},{"location":"02_data/#data","page":"Data and annotation formatting","title":"Data and annotation formatting","text":"","category":"section"},{"location":"02_data/","page":"Data and annotation formatting","title":"Data and annotation formatting","text":"JMAKi can operate directly on data files or inside the julia notebook. When are in a julia notebook the  format of single time series that want to be analyzed is a 2 x ntimepoints Matrix of FLoat64, e.g.,","category":"page"},{"location":"02_data/","page":"Data and annotation formatting","title":"Data and annotation formatting","text":" 0.0        2.0       4.0       6.0       8.0        10.0       10.0       12.0       14.0       16.0       18.0       20.0       22.0      24.0      26.0       28.0       30.0       32.0       34.0       36.0         \n 0.0912154  0.107956  0.105468  0.101727  0.0931484   0.106318   0.103697   0.139821   0.173598   0.204888   0.251052   0.289018   0.31298   0.33752   0.359356   0.370861   0.376347   0.383732   0.398496   0.384511   \n","category":"page"},{"location":"02_data/","page":"Data and annotation formatting","title":"Data and annotation formatting","text":"The first row should be time and the second the quantity to be fitted (e.g., Optical Density or CFU)","category":"page"},{"location":"02_data/","page":"Data and annotation formatting","title":"Data and annotation formatting","text":"Instead, three APIs call direclty the files: the user must input  the paths to  a .csv data file and a .csv annotation to the functions of JMAKi.jl ; In these cases JMAKi expect for data a matrix where the first row are the names of the wells and the columns the numerical value of the measurements. Note that the first one will be used as time:","category":"page"},{"location":"02_data/","page":"Data and annotation formatting","title":"Data and annotation formatting","text":"Time,  A1,     A2,      A3, \n0.0,   0.09,   0.09,    0.087,\n1.0,   0.08,   0.011,   0.012,\n2.0,   0.011,  0.18,    0.1,\n3.0,   0.012,  0.32,    0.22,\n4.0,   0.008,  0.41,    0.122,","category":"page"},{"location":"02_data/","page":"Data and annotation formatting","title":"Data and annotation formatting","text":"JMAKi expect a \",\" as separator between columns","category":"page"},{"location":"02_data/","page":"Data and annotation formatting","title":"Data and annotation formatting","text":"The annotation file instead should be a two columns .csv file where the number of rows correspond to the number of wells, note that the name of the well should be the same between the data.csv and annotation.csv:","category":"page"},{"location":"02_data/","page":"Data and annotation formatting","title":"Data and annotation formatting","text":"A1, b\nA2, X\nA3, unique_ID\n","category":"page"},{"location":"02_data/","page":"Data and annotation formatting","title":"Data and annotation formatting","text":"as unique_ID the user can insert anything but consider that if two wells has the same ID the will be considered replicates. 'b' indicates that the well should be cosidered a blank and 'X' that the well should be discarded from any analysis","category":"page"},{"location":"02_data/","page":"Data and annotation formatting","title":"Data and annotation formatting","text":"See the folders  XXXXX for some examples. ","category":"page"},{"location":"02_data/","page":"Data and annotation formatting","title":"Data and annotation formatting","text":"If a OD calibration curved is provided it should have the following format XXXXXXX","category":"page"}]
}
